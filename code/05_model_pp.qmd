---
title: |
  Code Notebook
subtitle: |
  How does reported partisan attachement influence affective polarization?: A comparative study of 25 European democracies
author:
  - name: Tristan Muno
    email: tristan.muno@uni-mannheim.de
    affiliations:
      - name: University of Mannheim
        department: School of Social Sciences
date: last-modified
date-format: MMMM D, YYYY
format:
  html:
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
execute:
  echo: true
  warning: true
  eval: true
  message: true
---

# Setup

```{r}
#| label: setup

# To track render duration
start_time <- Sys.time()

# set width of console output
# options(width = 80)

# Install and load required packages
p_required <- c(
  "tidyverse",
  "here",
  "brms",
  "broom.mixed",
  "sessioninfo"
)
packages <- rownames(installed.packages())
p_to_install <- p_required[!(p_required %in% packages)]
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_required, require, character.only = TRUE)
rm(p_required, p_to_install, packages)
```

# Load models

```{r}
#| label: load-models

load(here("data", "03_final", "models", "bfit_base_d.RData"))

load(here("data", "03_final", "models", "bfit_base_t.RData"))

# load(here("data", "03_final", "models", "bfit_cov_d.RData"))

# load(here("data", "03_final", "models", "bfit_cov_t.RData"))

```

# Model summary

```{r, message = NA}
#| label: model-summary

all_models <- ls(pattern = "^bfit")

fit_summary_fun <- function(model_name) {
  model_fit <- get(model_name)

  message(paste("Calling broom.mixed::tidy() on", model_name, "\n"))
  broom.mixed::tidy(model_fit, rhat = T, ess = T) |> print(n = 100)

  message(paste("Generating traceplots for", model_name, "\n"))
  plot(model_fit, ask = FALSE)

  message(paste("Generating pp_check for", model_name, "\n"))
  print(pp_check(model_fit, ndraws = 100))
}

for (i in all_models) {
  message(paste("Processing model", i, "\n"))
  fit_summary_fun(i)
}


```

# Expected values simulations

We want for each of the 4 models 6 QoI (24 in total):

EV(Y|co & impl); EV(Y|co &expl)
EV(Y|out & impl); EV(Y|out &expl)
EV(Y|none & impl); EV(Y|none &expl)

and then for comparative * 25 countries:
EV(Y|co & impl & country[i]); EV(Y|co &expl& country[i])
EV(Y|out & impl& country[i]); EV(Y|out &expl& country[i])
EV(Y|none & impl& country[i]); EV(Y|none &expl& country[i])

So, it makes most sense to create a function that takes newdata grid as input and outputs EV, ideally with observed values approach.

Pseude-code:
1. funtion to generate newdata grid, 
    - input: model (to extract data), T and R value
    - output newdata grid
2. function to estimate EVs
    - input: model (for effects), newdata
    - output: 6 EV vectors
3. function to estimate QoIs
    - input: EV vectors
    - output: AP (2x), IF (2x), OD (2x), CATE_AP, CATE_IF, CATE_OD
4- function to ggplot main effects
    - input: QoIs
    - output: ggplot object (exact structure tbto)


## Preparing the functions, the pipeline

### Step 1: Generating newdata 

Following conceptual observed

```{r}
#| label: create-newdata-function

# 1. Function to generate the APE newdata grid (T_i x R_ri combinations)
# ----------------------------------------------------------------------

#' Creates the required 'newdata' grid for the Observed Value Approach (APE)
#'
#' Generates 6 copies of the original data, fixing the focal covariates
#' (Partisan Type T and Partisan Relationship R) in each copy.
#'
#' @param bfit_model The fitted brms model object.
#' @param focal_T Vector of T values (e.g., c(0, 1)).
#' @param focal_R Vector of R factor levels (e.g., c("Co", "Out", "None")).
#' @return A named list of 6 tibbles (N rows each), ready for separate epred() calls.
create_ape_newdata <- function(
  bfit_model,
  focal_T = c(0, 1),
  focal_R = c("Co", "Out", "None")
) {
  original_data <- bfit_model[["data"]] |> as_tibble()

  # Ensure 'der_partisan_relationship' is a factor and levels are consistent
  R_levels <- levels(original_data$der_partisan_relationship)
  if (is.null(R_levels) || length(R_levels) == 0) {
    stop(
      "Column 'der_partisan_relationship' must be a factor in the model data."
    )
  }

  focal_combinations <- expand_grid(T_val = focal_T, R_val = focal_R)
  newdata_list <- list()

  for (i in 1:nrow(focal_combinations)) {
    T_set <- focal_combinations$T_val[i]
    R_set <- focal_combinations$R_val[i]

    new_df <- original_data |>
      mutate(
        # Set the focal T value (Partisan Type) for ALL observations
        der_partisan_type = T_set,

        # Set the focal R value (Partisan Relationship) for ALL observations
        der_partisan_relationship = factor(R_set, levels = R_levels)
      )

    # Use condition_id as the list name
    condition_id <- paste0("T", T_set, "_R", R_set)

    newdata_list[[condition_id]] <- new_df
  }

  # Return the named list of 6 individual data frames
  return(newdata_list)
}

```

### Step 2

```{r}
#| label: estimate-evs-function

# 2. Function to estimate Expected Values (EVs) using epred()
# -----------------------------------------------------------

#' Estimates Expected Values (EVs) by running epred() separately for each T x R scenario.
#'
#' @param bfit_model The fitted brms model object.
#' @param newdata_list The named list of 6 data frames created by create_ape_newdata().
#' @param re_formula_setting Use NULL for pooled APE (marginalizing REs) or
#'        TRUE for conditional APE (including REs for country/anchor).
#' @return A named list of 6 posterior matrices, each [Draws x N], or NULL if epred fails.
estimate_evs <- function(bfit_model, newdata_list, re_formula_setting = NULL) {
  n_scen <- newdata_list |> length()

  message(paste0(
    "Running posterior_epred() for: ",
    deparse(substitute(bfit_model)),
    "; separately for ",
    n_scen,
    " scenarios with re_formula = ",
    deparse(substitute(re_formula_setting))
  ))

  epreds_list <- map(names(newdata_list), function(cond_name) {
    df <- newdata_list[[cond_name]]

    # Calculate the posterior expected values
    epreds_matrix <- tryCatch(
      {
        posterior_epred(
          bfit_model,
          newdata = df,
          re_formula = re_formula_setting
        )
      },
      error = function(e) {
        warning(paste(
          "posterior_epred() failed for condition",
          cond_name,
          ". Error:",
          e$message
        ))
        return(NULL)
      }
    )

    return(epreds_matrix)
  }) |>
    set_names(names(newdata_list))

  # Check if any epred failed
  if (any(map_lgl(epreds_list, is.null))) {
    warning("One or more epred calls failed. Check warnings above.")
    return(NULL)
  }

  # N = Original number of observations (used for checks in calling script)
  N <- nrow(bfit_model[["data"]])

  return(list(
    epreds_list = epreds_list,
    N_obs = N
  ))
}
```

### Step 4

```{r}
#| label: tidy-qoi-function

# 3. Function to estimate QoIs (AP, IF, OD, CATEs) and tidy the output
# --------------------------------------------------------------------

#' Calculates and tidies the posterior distributions for all Quantities of Interest (QoIs).
#'
#' This function takes the epred list output, applies the row filter (for country/overall),
#' calculates the APE (rowMeans), then calculates AP/IF/OD and CATEs,
#' and returns the result in a long format suitable for tidybayes.
#'
#' @param epred_result The list output from estimate_evs() containing epreds_list.
#' @param filter_rows A vector of row indices from the *original* data (1 to N)
#'        to include in the APE calculation (e.g., all N for overall, or a subset
#'        for a specific country).
#' @param analysis_id A character string identifying the analysis (e.g., "Pooled", "Austria").
#' @return A long-format tibble ready for tidybayes/ggplot2.
calculate_qois_tidy <- function(
  epred_result,
  filter_rows = 1:epred_result$N_obs,
  analysis_id = "Pooled"
) {
  # Check for failed epred result
  if (is.null(epred_result) || is.null(epred_result$epreds_list)) {
    warning(
      "Cannot calculate QoIs: epred_result is NULL or missing epreds_list."
    )
    return(tibble())
  }

  epreds_list <- epred_result$epreds_list

  # --- Step A: Calculate the 6 APEs (rowMeans) for the specified filter_rows ---
  # Iterate over the 6 posterior matrices
  ape_posteriors <- purrr::map(names(epreds_list), function(cond_name) {
    epred_matrix <- epreds_list[[cond_name]]

    # 1. Subset the matrix rows based on the filter_rows (for country/overall)
    # epred_matrix is [Draws x N], so we subset the columns here
    epred_subset <- epred_matrix[, filter_rows]

    # 2. Calculate the APE for this specific condition and filtered group
    return(rowMeans(epred_subset))
  }) |>
    # Name the resulting list of vectors (the 6 APE distributions)
    set_names(names(epreds_list)) |>
    as_tibble()

  # --- Step B: Calculate the difference QoIs (AP, IF, OD, CATEs) ---

  AP_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_ROut
  AP_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_ROut
  IF_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_RNone
  IF_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_RNone
  OD_T1 <- ape_posteriors$T1_RNone - ape_posteriors$T1_ROut
  OD_T0 <- ape_posteriors$T0_RNone - ape_posteriors$T0_ROut
  CATE_AP <- AP_T1 - AP_T0
  CATE_IF <- IF_T1 - IF_T0
  CATE_OD <- OD_T1 - OD_T0

  # --- Step C: Combine and Transform to Tidy (Long) Format ---

  all_qois_wide <- ape_posteriors |>
    add_column(
      AP_Expl = AP_T1,
      AP_Impl = AP_T0,
      IF_Expl = IF_T1,
      IF_Impl = IF_T0,
      OD_Expl = OD_T1,
      OD_Impl = OD_T0,
      CATE_AP = CATE_AP,
      CATE_IF = CATE_IF,
      CATE_OD = CATE_OD
    ) |>
    mutate(.draw = 1:n()) |> # Mandatory column for tidybayes
    mutate(Analysis = analysis_id)

  qois_tidy <- all_qois_wide |>
    pivot_longer(
      cols = -c(.draw, Analysis),
      names_to = "Quantity",
      values_to = "Estimate"
    )

  return(qois_tidy)
}

```

```{r}
#| label: plot-function

# 4. Function to ggplot main effects (Halfeye of conditional means and CATE)
# -------------------------------------------------------------------------

#' Generates the ggplot object for the pooled (main) effects.
#'
#' @param tidybayes_df The output from calculate_qois_tidy() filtered for the "Pooled" analysis.
#' @return A ggplot object.
plot_pooled_results <- function(tidybayes_df) {
  # 1. Prepare data for the two panels

  # Left Panel: Conditional Means (EVs)
  ev_data <- tidybayes_df |>
    filter(
      Quantity %in%
        c("T1_RCo", "T0_RCo", "T1_ROut", "T0_ROut", "T1_RNone", "T0_RNone")
    ) |>
    separate_wider_delim(
      Quantity,
      delim = "_",
      names = c("Partisan_Type", "Relationship_Code")
    ) |>
    mutate(
      Partisan_Type = factor(
        Partisan_Type,
        levels = c("T1", "T0"),
        labels = c("Explicit Partisan (T=1)", "Implicit Partisan (T=0)")
      ),
      Relationship_Type = factor(
        Relationship_Code,
        levels = c("RCo", "ROut", "RNone"),
        labels = c("Co-Partisan", "Out-Partisan", "Neutral")
      )
    ) |>
    select(-Relationship_Code)

  # Right Panel: Polarization/Favoritism/Derogation (AP, IF, OD, CATEs)
  qoi_data <- tidybayes_df |>
    filter(
      Quantity %in%
        c(
          "AP_Expl",
          "AP_Impl",
          "IF_Expl",
          "IF_Impl",
          "OD_Expl",
          "OD_Impl",
          "CATE_AP",
          "CATE_IF",
          "CATE_OD"
        )
    ) |>
    mutate(
      Metric = case_when(
        grepl("CATE", Quantity) ~ "CATE",
        grepl("AP", Quantity) ~ "AP",
        grepl("IF", Quantity) ~ "IF",
        grepl("OD", Quantity) ~ "OD"
      ),
      Type = case_when(
        Metric == "CATE" ~ "Causal Effect (CATE)",
        grepl("Expl", Quantity) ~ "Explicit Partisan",
        grepl("Impl", Quantity) ~ "Implicit Partisan",
        TRUE ~ NA_character_
      )
    )

  # Function to generate individual facet plots for AP, IF, OD
  generate_qoi_plot <- function(metric_abbr) {
    qoi_metric_data <- qoi_data |> filter(Metric == metric_abbr)

    # Calculate order for the plot (CATE first, then Explicit, then Implicit)
    qoi_metric_data$Plot_Order <- factor(
      qoi_metric_data$Type,
      levels = c(
        "Causal Effect (CATE)",
        "Explicit Partisan",
        "Implicit Partisan"
      )
    )

    # Determine appropriate title
    full_name <- switch(
      metric_abbr,
      "AP" = "Affective Polarization (AP)",
      "IF" = "Ingroup Favoritism (IF)",
      "OD" = "Outgroup Derogation (OD)",
      metric_abbr
    )

    # Calculate the range for consistent x-limits across the three plots
    # Note: We use the range of the whole QoI set for consistent X-axis across AP, IF, OD
    max_range <- max(abs(qoi_data$Estimate)) * 1.1

    p_right <- ggplot(
      qoi_metric_data,
      aes(x = Estimate, y = Plot_Order, fill = Type)
    ) +
      stat_halfeyeh(
        .width = 0.95,
        point_interval = "median_qi",
        slab_size = 0.5,
        linewidth = 1 # line size for the CI interval
      ) +
      geom_vline(xintercept = 0, linetype = "dashed", color = "red") +
      scale_fill_manual(
        values = c(
          "Causal Effect (CATE)" = "#0072B2",
          "Explicit Partisan" = "#E69F00",
          "Implicit Partisan" = "#56B4E9"
        ),
        name = "Group/Effect"
      ) +
      labs(
        title = full_name,
        y = NULL,
        x = "Effect Size (Tokens)"
      ) +
      coord_cartesian(xlim = c(-max_range, max_range)) +
      theme_minimal(base_size = 12) +
      theme(legend.position = "none")

    return(p_right)
  }

  # Left panel: Conditional Means (EVs)
  p_left <- ggplot(
    ev_data,
    aes(x = Estimate, y = Relationship_Type, fill = Partisan_Type)
  ) +
    stat_halfeyeh(
      .width = 0.95,
      point_interval = "median_qi",
      slab_size = 0.5,
      linewidth = 1
    ) +
    facet_wrap(~Partisan_Type, ncol = 1) +
    scale_fill_manual(
      values = c(
        "Explicit Partisan (T=1)" = "#E69F00",
        "Implicit Partisan (T=0)" = "#56B4E9"
      ),
      name = "Partisan Type"
    ) +
    labs(
      title = "Conditional Predicted Expected Value (EV)",
      x = "Tokens Allocated (0-10)",
      y = "Relationship Type"
    ) +
    theme_minimal(base_size = 12) +
    theme(
      legend.position = "bottom",
      strip.background = element_rect(fill = "grey90", color = "grey50")
    )

  # Right panels: AP, IF, OD
  p_ap <- generate_qoi_plot("AP")
  p_if <- generate_qoi_plot("IF")
  p_od <- generate_qoi_plot("OD")

  # Combine plots using a patchwork-like structure (conceptual, user needs to implement)
  # For R script output, we return a list of plots.
  return(list(
    Conditional_Means_Plot = p_left,
    AP_Plot = p_ap,
    IF_Plot = p_if,
    OD_Plot = p_od
  ))
}
```

```{r}
#| label: testing-ground

newdata_base_d <- create_ape_newdata(bfit_base_d)

# test with 1 scenario
newdata_base_d_T0_RCo <- newdata_base_d[["T0_RCo"]]
evs_base_d <- estimate_evs(bfit_base_d, newdata_base_d_T0_RCo)

```

# Session Info

```{r}
#| label: session-info

session_info()
```


# Render Time

```{r}
#| label: render-time

end_time <- Sys.time()

rendering_time <- end_time - start_time

message(paste(
  "Document rendered in:",
  round(as.numeric(rendering_time, units = "secs"), 2),
  "seconds.
"
))
```