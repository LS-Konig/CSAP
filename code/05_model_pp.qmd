---
title: |
  Code Notebook
subtitle: |
  How does reported partisan attachement influence affective polarization?: A comparative study of 25 European democracies
author:
  - name: Tristan Muno
    email: tristan.muno@uni-mannheim.de
    affiliations:
      - name: University of Mannheim
        department: School of Social Sciences
date: last-modified
date-format: MMMM D, YYYY
format:
  html:
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
execute:
  echo: true
  warning: true
  eval: true
  message: true
---

# Setup

```{r}
#| label: setup

# To track render duration
start_time <- Sys.time()

# set width of console output
# options(width = 80)

# Install and load required packages
p_required <- c(
  "tidyverse",
  "here",
  "brms",
  "broom.mixed",
  "tidybayes",
  "ggpubr",
  "patchwork",
  "knitr",
  "sessioninfo"
)
packages <- rownames(installed.packages())
p_to_install <- p_required[!(p_required %in% packages)]
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_required, require, character.only = TRUE)
rm(p_required, p_to_install, packages)
```

# Load models

```{r}
#| label: load-models

load(here("data", "03_final", "models", "bfit_base_d.RData"))

load(here("data", "03_final", "models", "bfit_base_t.RData"))

load(here("data", "03_final", "models", "bfit_cov_d.RData"))

load(here("data", "03_final", "models", "bfit_cov_t.RData"))

```

# Model summary

```{r, message = NA}
#| label: model-summary

all_models <- ls(pattern = "^bfit")

fit_summary_fun <- function(model_name) {
  model_fit <- get(model_name)

  message(paste("Calling summary() on", model_name, "\n"))
  summary(model_fit, rhat = T, ess = T)

  message(paste("Calling broom.mixed::tidy() on", model_name, "\n"))
  broom.mixed::tidy(model_fit, rhat = T, ess = T) |> kable()

  message(paste("Generating traceplots for", model_name, "\n"))
  plot(model_fit, ask = FALSE)

  message(paste("Generating pp_check for", model_name, "\n"))
  print(pp_check(model_fit, ndraws = 100))
}

for (i in all_models) {
  message(paste("Processing model", i, "\n"))
  fit_summary_fun(i)
}


```

# Expected values simulations

We want for each of the 4 models 6 QoI (24 in total):

EV(Y|co & impl); EV(Y|co &expl)
EV(Y|out & impl); EV(Y|out &expl)
EV(Y|none & impl); EV(Y|none &expl)

and then for comparative * 25 countries:
EV(Y|co & impl & country[i]); EV(Y|co &expl& country[i])
EV(Y|out & impl& country[i]); EV(Y|out &expl& country[i])
EV(Y|none & impl& country[i]); EV(Y|none &expl& country[i])

So, it makes most sense to create a function that takes newdata grid as input and outputs EV, ideally with observed values approach.

Pseude-code:
1. funtion to generate newdata grid, 
    - input: model (to extract data), T and R value
    - output newdata grid
2. function to estimate EVs
    - input: model (for effects), newdata
    - output: 6 EV vectors
3. function to estimate QoIs
    - input: EV vectors
    - output: AP (2x), IF (2x), OD (2x), CATE_AP, CATE_IF, CATE_OD
4- function to ggplot main effects
    - input: QoIs
    - output: ggplot object (exact structure tbto)


## Preparing the functions, the pipeline

### Step 1: Generating newdata 

Following conceptual observed

```{r}
#| label: create-newdata-function

# 1. Function to generate the APE newdata grid (T_i x R_ri combinations)
# ----------------------------------------------------------------------

#' Creates the required 'newdata' grid for the Observed Value Approach (APE)
#'
#' Generates 6 copies of the original data, fixing the focal covariates
#' (Partisan Type T and Partisan Relationship R) in each copy.
#'
#' @param bfit_model The fitted brms model object.
#' @param focal_T Vector of T values (e.g., c(0, 1)).
#' @param focal_R Vector of R factor levels (e.g., c("Co", "Out", "None")).
#' @return A named list of 6 tibbles (N rows each), ready for separate epred() calls.
create_ape_newdata <- function(
  bfit_model,
  focal_T = c(0, 1),
  focal_R = c("Co", "Out", "None")
) {
  original_data <- bfit_model[["data"]] |> as_tibble()

  # Ensure 'der_partisan_relationship' is a factor and levels are consistent
  R_levels <- levels(original_data$der_partisan_relationship)
  if (is.null(R_levels) || length(R_levels) == 0) {
    stop(
      "Column 'der_partisan_relationship' must be a factor in the model data."
    )
  }

  focal_combinations <- expand_grid(T_val = focal_T, R_val = focal_R)
  newdata_list <- list()

  for (i in 1:nrow(focal_combinations)) {
    T_set <- focal_combinations$T_val[i]
    R_set <- focal_combinations$R_val[i]

    new_df <- original_data |>
      mutate(
        # Set the focal T value (Partisan Type) for ALL observations
        der_partisan_type = T_set,

        # Set the focal R value (Partisan Relationship) for ALL observations
        der_partisan_relationship = factor(R_set, levels = R_levels)
      )

    # Use condition_id as the list name
    condition_id <- paste0("T", T_set, "_R", R_set)

    newdata_list[[condition_id]] <- new_df
  }

  # Return the named list of 6 individual data frames
  return(newdata_list)
}

```

### Step 2

```{r}
#| label: estimate-evs-function

# 2. Function to estimate Expected Values (EVs) using epred()
# -----------------------------------------------------------

#' Estimates Expected Values (EVs) by running epred() separately for each T x R scenario.
#'
#' @param bfit_model The fitted brms model object.
#' @param newdata_list The named list of 6 data frames created by create_ape_newdata().
#' @param re_formula_setting Use NULL for pooled APE (marginalizing REs) or
#'        TRUE for conditional APE (including REs for country/anchor).
#' @return A named list of 6 posterior matrices, each [Draws x N], or NULL if epred fails.
estimate_evs <- function(bfit_model, newdata_list, re_formula_setting = NULL) {
  n_scen <- newdata_list |> length()

  message(paste0(
    "Running posterior_epred() for: ",
    deparse(substitute(bfit_model)),
    "; separately for ",
    n_scen,
    " scenarios with re_formula = ",
    deparse(substitute(re_formula_setting))
  ))

  epreds_list <- map(names(newdata_list), function(cond_name) {
    df <- newdata_list[[cond_name]]

    # Calculate the posterior expected values
    epreds_matrix <- tryCatch(
      {
        posterior_epred(
          bfit_model,
          newdata = df,
          re_formula = re_formula_setting
        )
      },
      error = function(e) {
        warning(paste(
          "posterior_epred() failed for condition",
          cond_name,
          ". Error:",
          e$message
        ))
        return(NULL)
      }
    )

    return(epreds_matrix)
  }) |>
    set_names(names(newdata_list))

  # Check if any epred failed
  if (any(map_lgl(epreds_list, is.null))) {
    warning("One or more epred calls failed. Check warnings above.")
    return(NULL)
  }

  # N = Original number of observations (used for checks in calling script)
  N <- nrow(bfit_model[["data"]])

  return(list(
    epreds_list = epreds_list,
    N_obs = N
  ))
}
```

### Step 3

```{r}
#| label: tidy-qoi-function

# 3. Function to estimate QoIs (AP, IF, OD, CATEs) and tidy the output
# --------------------------------------------------------------------

#' Calculates and tidies the posterior distributions for all Quantities of Interest (QoIs).
#'
#' This function takes the epred list output, applies the row filter (for country/overall),
#' calculates the APE (rowMeans), then calculates AP/IF/OD and CATEs,
#' and returns the result in a long format suitable for tidybayes.
#'
#' @param epred_result The list output from estimate_evs() containing epreds_list.
#' @param filter_rows A vector of row indices from the *original* data (1 to N)
#'        to include in the APE calculation (e.g., all N for overall, or a subset
#'        for a specific country).
#' @param analysis_id A character string identifying the analysis (e.g., "Pooled", "Austria").
#' @return A long-format tibble ready for tidybayes/ggplot2.
calculate_qois_tidy <- function(
  epred_result,
  filter_rows = 1:epred_result$N_obs,
  analysis_id = "Pooled"
) {
  # Check for failed epred result
  if (is.null(epred_result) || is.null(epred_result$epreds_list)) {
    warning(
      "Cannot calculate QoIs: epred_result is NULL or missing epreds_list."
    )
    return(tibble())
  }

  epreds_list <- epred_result$epreds_list

  # --- Step A: Calculate the 6 APEs (rowMeans) for the specified filter_rows ---
  # Iterate over the 6 posterior matrices
  ape_posteriors <- purrr::map(names(epreds_list), function(cond_name) {
    epred_matrix <- epreds_list[[cond_name]]

    # 1. Subset the matrix rows based on the filter_rows (for country/overall)
    # epred_matrix is [Draws x N], so we subset the columns here
    epred_subset <- epred_matrix[, filter_rows]

    # 2. Calculate the APE for this specific condition and filtered group
    return(rowMeans(epred_subset))
  }) |>
    # Name the resulting list of vectors (the 6 APE distributions)
    set_names(names(epreds_list)) |>
    as_tibble()

  # --- Step B: Calculate the difference QoIs (AP, IF, OD, CATEs) ---

  AP_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_ROut
  AP_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_ROut
  IF_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_RNone
  IF_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_RNone
  OD_T1 <- ape_posteriors$T1_RNone - ape_posteriors$T1_ROut
  OD_T0 <- ape_posteriors$T0_RNone - ape_posteriors$T0_ROut
  CATE_AP <- AP_T1 - AP_T0
  CATE_IF <- IF_T1 - IF_T0
  CATE_OD <- OD_T1 - OD_T0

  # --- Step C: Combine and Transform to Tidy (Long) Format ---

  all_qois_wide <- ape_posteriors |>
    add_column(
      AP_Expl = AP_T1,
      AP_Impl = AP_T0,
      IF_Expl = IF_T1,
      IF_Impl = IF_T0,
      OD_Expl = OD_T1,
      OD_Impl = OD_T0,
      CATE_AP = CATE_AP,
      CATE_IF = CATE_IF,
      CATE_OD = CATE_OD
    ) |>
    mutate(.draw = 1:n()) |> # Mandatory column for tidybayes
    mutate(Analysis = analysis_id)

  qois_tidy <- all_qois_wide |>
    pivot_longer(
      cols = -c(.draw, Analysis),
      names_to = "Quantity",
      values_to = "Estimate"
    )

  return(qois_tidy)
}

```

### Step 4

```{r}
#| label: plot-function

# 4. Function to ggplot main effects (Halfeye of conditional means and CATE)
# -------------------------------------------------------------------------

#' Generates the ggplot object for the pooled (main) effects.
#'
#' This function generates two plots: one for the 6 Expected Values (EVs)
#' and one combined, faceted plot for the 9 Difference Metrics (AP/IF/OD x Expl/Impl/CATE).
#'
#' @param tidybayes_df The output from calculate_qois_tidy() filtered for the "Pooled" analysis.
#' @return A list of two ggplot objects: Conditional_Means_Plot and QoI_CATE_Plot.
plot_pooled_results <- function(tidybayes_df) {
  # 1. Prepare data for the two panels

  # --- Left Panel: Conditional Means (EVs) ---
  ev_data <- tidybayes_df |>
    filter(
      Quantity %in%
        c("T1_RCo", "T0_RCo", "T1_ROut", "T0_ROut", "T1_RNone", "T0_RNone")
    ) |>
    separate_wider_delim(
      Quantity,
      delim = "_",
      names = c("Partisan_Type", "Relationship_Code")
    ) |>
    mutate(
      Partisan_Type = factor(
        Partisan_Type,
        levels = c("T1", "T0"),
        labels = c("Explicit Partisan (T=1)", "Implicit Partisan (T=0)")
      ),
      Relationship_Type = factor(
        Relationship_Code,
        levels = c("RCo", "ROut", "RNone"),
        labels = c("Co-Partisan", "Out-Partisan", "Neutral")
      )
    ) |>
    select(-Relationship_Code)

  # --- Right Panel: Polarization/Favoritism/Derogation (AP, IF, OD, CATEs) ---
  qoi_data <- tidybayes_df |>
    filter(
      Quantity %in%
        c(
          "AP_Expl",
          "AP_Impl",
          "IF_Expl",
          "IF_Impl",
          "OD_Expl",
          "OD_Impl",
          "CATE_AP",
          "CATE_IF",
          "CATE_OD"
        )
    ) |>
    mutate(
      Metric_Code = case_when(
        grepl("CATE", Quantity) ~ gsub("CATE_", "", Quantity), # e.g., AP, IF, OD
        grepl("AP", Quantity) ~ "AP",
        grepl("IF", Quantity) ~ "IF",
        grepl("OD", Quantity) ~ "OD"
      ),
      Type = case_when(
        grepl("CATE", Quantity) ~ "Conditional Average Treatment Effect",
        grepl("Expl", Quantity) ~ "Explicit\n(T=1)",
        grepl("Impl", Quantity) ~ "Implicit\n(T=0)",
        TRUE ~ NA_character_
      )
    ) |>
    # Convert Metric to clean factor for plotting order
    mutate(
      Metric_Name = factor(
        Metric_Code,
        levels = c("AP", "IF", "OD"),
        labels = c(
          "Affective Polarization (AP)",
          "Ingroup Favoritism (IF)",
          "Outgroup Derogation (OD)"
        )
      ),
      # Set plotting order for the y-axis within each facet
      Plot_Order = factor(
        Type,
        levels = c(
          "Conditional Average Treatment Effect",
          "Implicit\n(T=0)",
          "Explicit\n(T=1)"
        )
      )
    )

  # --- PLOT GENERATION ---

  # Left panel: Conditional Means (EVs)
  p_ev <- ggplot(
    ev_data,
    aes(
      x = Estimate,
      y = Relationship_Type,
      fill = Partisan_Type
    )
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    facet_wrap(~Partisan_Type, ncol = 1) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "grey"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Tokens Allocated (0-10)",
      y = "Relationship Type"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  # Right panel: Combined QoI and CATE effects
  max_range <- max(abs(qoi_data$Estimate)) * 1.1

  # FIG: AP --------------------------------------------------------------------
  p_ap_left <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "AP",
        Type != "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order, fill = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "#CCCCCC"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Affective Polarization (AP)",
      y = "Partisan Type (T)"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  p_ap_right <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "AP",
        Type == "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1.5
    ) +
    labs(
      x = expression(CATE[AP]),
      y = " "
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1.618034,
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    )

  p_ap <- p_ap_left + p_ap_right

  # FIG: IF --------------------------------------------------------------------
  p_if_left <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "IF",
        Type != "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order, fill = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "#CCCCCC"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Ingroup Favoritism (IF)",
      y = "Partisan Type (T)"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  p_if_right <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "IF",
        Type == "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1.5
    ) +
    labs(
      x = expression(CATE[IF]),
      y = " "
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1.618034,
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    )

  p_if <- p_if_left + p_if_right

  # FIG: OD --------------------------------------------------------------------
  p_od_left <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "OD",
        Type != "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order, fill = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "#CCCCCC"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Outgroup Derogation (OD)",
      y = "Partisan Type (T)"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  p_od_right <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "OD",
        Type == "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1.5
    ) +
    labs(
      x = expression(CATE[OD]),
      y = " "
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1.618034,
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank()
    )

  p_od <- p_od_left + p_od_right

  # Return the two main plots
  return(list(
    Conditional_Means_Plot = p_ev,
    AP_Plot = p_ap,
    IF_Plot = p_if,
    OD_Plot = p_od
  ))
}
```

# Run pipelines

## Pooled analyses

### Base model d

```{r, message = NA}
#| label: analysis-base-d

newdata_base_d <- create_ape_newdata(bfit_base_d)

evs_base_d <- estimate_evs(bfit_base_d, newdata_base_d)

qois_base_d <- calculate_qois_tidy(evs_base_d)

plot_base_d <- plot_pooled_results(qois_base_d)

save(
  plot_base_d,
  file = here(
    "data",
    "03_final",
    "plot_base_d.RData"
  )
)
```

### Base model t

```{r, message = NA}
#| label: analysis-base-t

newdata_base_t <- create_ape_newdata(bfit_base_t)

evs_base_t <- estimate_evs(bfit_base_t, newdata_base_t)

qois_base_t <- calculate_qois_tidy(evs_base_t)

plot_base_t <- plot_pooled_results(qois_base_t)

save(
  plot_base_t,
  file = here(
    "data",
    "03_final",
    "plot_base_t.RData"
  )
)
```

### Cov model d

```{r, message = NA}
#| label: analysis-cov-d

newdata_base_d <- create_ape_newdata(bfit_base_d)

evs_base_d <- estimate_evs(bfit_base_d, newdata_base_d)

qois_base_d <- calculate_qois_tidy(evs_base_d)

plot_base_d <- plot_pooled_results(qois_base_d)

save(
  plot_cov_d,
  file = here(
    "data",
    "03_final",
    "plot_cov_d.RData"
  )
)
```

### Cov model t

```{r, message = NA}
#| label: analysis-cov-t

newdata_base_t <- create_ape_newdata(bfit_base_t)

evs_base_t <- estimate_evs(bfit_base_t, newdata_base_t)

qois_base_t <- calculate_qois_tidy(evs_base_t)

plot_base_t <- plot_pooled_results(qois_base_t)

save(
  plot_cov_t,
  file = here(
    "data",
    "03_final",
    "plot_cov_t.RData"
  )
)
```

## Country analyses

### Base d

### Base t

### Cov d

### Cov t

# Session Info

```{r}
#| label: session-info

session_info()
```


# Render Time

```{r}
#| label: render-time

end_time <- Sys.time()

rendering_time <- end_time - start_time

message(paste(
  "Document rendered in:",
  round(as.numeric(rendering_time, units = "secs"), 2),
  "seconds.
"
))
```