---
title: |
  Code Notebook 3.2
subtitle: |
  AP Measures
date: last-modified
date-format: MMMM D, YYYY
format:
  html:
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
execute:
  echo: true
  warning: true
  eval: true
  message: true
---

# Setup

```{r}
#| label: setup

# To track render duration
start_time <- Sys.time()

# set width of console output
options(width = 80)


# Install and load required packages
p_required <- c(
  "tidyverse",
  "here",
  "sessioninfo"
)
packages <- rownames(installed.packages())
p_to_install <- p_required[!(p_required %in% packages)]
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_required, require, character.only = TRUE)
rm(p_required, p_to_install, packages)
```

# Load Data

```{r}
#| label: load-data

eu25games2019 <- readRDS(
  file = here(
    "data",
    "03_final",
    "eu25games2019.rds"
  )
)
```

# Overview of Measures

For our behavioral experiment, we conceptually draw from Reiljan's API.
Formally, we define AP as the difference in tokens allocated to the ingroup, minus the average number of tokens allocated to all outgroups. 

Weighted and unweighted

For the thermometer score, we calculate three measures, each weighted and unweighted:

Reiljan API
Wagner Mean Distance
Wagner Spread of Scores

We compare the levels across identifiers, voters (without identity) and nonpartisans (Wagner)

# Party sizes (for weighting)

What to use, empirical distributions in sample (id/vote?) or electoral vote share in 2019? Both?

```{r}
#| label: party-shares-vote-variable

# relative (reported) vote shares
votes_per_country <- eu25games2019 |>
  select(
    meta_country,
    meta_pid,
    der_vote_combined_name
  ) |>
  distinct(meta_pid, .keep_all = T) |>
  filter(
    der_vote_combined_name != "dont-know" &
      der_vote_combined_name != "other"
  ) |>
  group_by(meta_country, der_vote_combined_name) |>
  count(der_vote_combined_name) |>
  ungroup() |>
  group_by(meta_country) |>
  summarise(
    abs_vote = sum(n)
  )

votes_per_party <- eu25games2019 |>
  select(
    meta_country,
    meta_pid,
    der_vote_combined_name
  ) |>
  distinct(meta_pid, .keep_all = T) |>
  filter(
    der_vote_combined_name != "dont-know" &
      der_vote_combined_name != "other"
  ) |>
  group_by(meta_country, der_vote_combined_name) |>
  count(der_vote_combined_name) |>
  ungroup()

votes_per_party <- votes_per_party |>
  left_join(
    votes_per_country,
    by = join_by(meta_country)
  )

votes_per_party <- votes_per_party |>
  mutate(
    der_anchor_vote_share = n / abs_vote
  )

eu25games2019 <- eu25games2019 |>
  left_join(
    (votes_per_party |>
      select(
        der_vote_combined_name,
        der_anchor_vote_share
      )),
    by = join_by(der_partisan_anchor == der_vote_combined_name)
  )
```

# Target Table

What I want is a tibble in the format

| Measurement | measure | weighted | der_partisan_type | ap | ci_low | ci_high | 
|:--|:--------|:---------|:------------------|---:|-------:|--------:|
| Behavioral | API | N | Explicit | X | X | X |
| Behavioral | API  | N | Implicit | X | X | X |
| Behavioral | API  | N | Total | X | X | X |
| Behavioral | API  | Y | Explicit | X | X | X |
| Behavioral | API  | Y | Implicit | X | X | X |
| Behavioral | API  | Y | Total | X | X | X |
| Attitudinal | API  | N | Explicit | X | X | X |
| Attitudinal | API  | N | Implicit | X | X | X |
| Attitudinal | API  | N | Total | X | X | X |
| Attitudinal | API  | Y | Explicit | X | X | X |
| Attitudinal | API  | Y | Implicit | X | X | X |
| Attitudinal | API  | Y | Total | X | X | X |
| Attitudinal | Mean Dist. | N | Explicit | X | X | X |
| Attitudinal | Mean Dist. | N | Implicit | X | X | X |
| Attitudinal | Mean Dist. | N | None | X | X | X |
| Attitudinal | Mean Dist. | N | Total | X | X | X |
| Attitudinal | Mean Dist. | Y | Explicit | X | X | X |
| Attitudinal | Mean Dist. | Y | Implicit | X | X | X |
| Attitudinal | Mean Dist. | Y | None | X | X | X |
| Attitudinal | Mean Dist. | Y | Total | X | X | X |
| Attitudinal | Spread | N | Explicit | X | X | X |
| Attitudinal | Spread | N | Implicit | X | X | X |
| Attitudinal | Spread | N | None | X | X | X |
| Attitudinal | Spread | N | Total | X | X | X |
| Attitudinal | Spread | Y | Explicit | X | X | X |
| Attitudinal | Spread | Y | Implicit | X | X | X |
| Attitudinal | Spread | Y | None | X | X | X |
| Attitudinal | Spread | Y | Total | X | X | X |

# Aggregated AP: Token Allocation

```{r}
#| label: total-sample-ap-cj-unweighted

pooled_ap_cj <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type)
  ) |>
  group_by(der_partisan_type, der_partisan_relationship) |>
  summarise(
    mean = mean(cj_token),
    sd = sd(cj_token),
    n = n(),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = c(mean, sd, n)
  ) |>
  mutate(
    ap = mean_Co - mean_Out,
    se = sqrt(sd_Co^2 / n_Co + sd_Out^2 / n_Out),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff,
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )


total_pooled_ap_cj <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type)
  ) |>
  group_by(der_partisan_relationship) |>
  summarise(
    mean = mean(cj_token),
    sd = sd(cj_token),
    n = n(),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = c(mean, sd, n)
  ) |>
  mutate(
    ap = mean_Co - mean_Out,
    se = sqrt(sd_Co^2 / n_Co + sd_Out^2 / n_Out),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff
  ) |>
  mutate(der_partisan_type = "Total") |>
  relocate(der_partisan_type, .before = mean_Co)

pooled_ap_cj <- pooled_ap_cj |>
  bind_rows(total_pooled_ap_cj) |>
  mutate(measure = "Token")

pooled_ap_cj <- pooled_ap_cj |>
  select(
    der_partisan_type,
    ap = diff_mean,
    ci_low,
    ci_high
  ) |>
  mutate(
    measurement = "Behavioral",
    measure = "API",
    outcome = "Token",
    weighted = 0,
  )
```

```{r}
#| label: total-sample-ap-cj-weighted

pooled_ap_cj_weighted <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type)
  ) |>
  group_by(der_partisan_type, der_partisan_relationship) |>
  summarise(
    mean = weighted.mean(cj_token, w = der_anchor_vote_share, na.rm = TRUE),
    sd = sqrt(weighted.mean(
      (cj_token -
        weighted.mean(cj_token, w = der_anchor_vote_share, na.rm = TRUE))^2,
      w = der_anchor_vote_share,
      na.rm = TRUE
    )),
    n = n(),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = c(mean, sd, n)
  ) |>
  mutate(
    ap = mean_Co - mean_Out,
    se = sqrt(sd_Co^2 / n_Co + sd_Out^2 / n_Out),
    ci_low = ap - 1.96 * se,
    ci_high = ap + 1.96 * se,
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      TRUE ~ NA_character_
    )
  )


total_pooled_ap_cj_weighted <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type)
  ) |>
  summarise(
    mean_Co = weighted.mean(
      cj_token[der_partisan_relationship == "Co"],
      w = der_anchor_vote_share[der_partisan_relationship == "Co"],
      na.rm = TRUE
    ),
    mean_Out = weighted.mean(
      cj_token[der_partisan_relationship == "Out"],
      w = der_anchor_vote_share[der_partisan_relationship == "Out"],
      na.rm = TRUE
    ),
    sd_Co = sqrt(weighted.mean(
      (cj_token[der_partisan_relationship == "Co"] - mean_Co)^2,
      w = der_anchor_vote_share[der_partisan_relationship == "Co"],
      na.rm = TRUE
    )),
    sd_Out = sqrt(weighted.mean(
      (cj_token[der_partisan_relationship == "Out"] - mean_Out)^2,
      w = der_anchor_vote_share[der_partisan_relationship == "Out"],
      na.rm = TRUE
    )),
    n_Co = sum(der_partisan_relationship == "Co"),
    n_Out = sum(der_partisan_relationship == "Out")
  ) |>
  mutate(
    ap = mean_Co - mean_Out,
    se = sqrt(sd_Co^2 / n_Co + sd_Out^2 / n_Out),
    ci_low = ap - 1.96 * se,
    ci_high = ap + 1.96 * se,
    der_partisan_type = "Total"
  )

pooled_ap_cj_weighted <- bind_rows(
  pooled_ap_cj_weighted,
  total_pooled_ap_cj_weighted
) |>
  mutate(
    measurement = "Behavioral",
    measure = "API",
    outcome = "Token",
    weighted = 1
  )

```


# Aggregated AP: Thermometer Scores

There are three main operationalization strategies applied in European AP studies: Reiljan's API, Wagner's mean distance and Wagner's average spread.

I am starting simple, with unweighted variants of all three, beginning with Reiljan's API.

```{r}
#| label: total-sample-reiljan-api

# turn thermoscores to long format
thermo_long <- eu25games2019 |>
  select(
    meta_pid,
    der_partisan_type,
    der_partisan_anchor,
    starts_with("q_thermo_"),
    starts_with("ext_q_thermo_")
  ) |>
  pivot_longer(
    cols = matches("^q_thermo_[0-9]+$"),
    names_to = "thermo_slot",
    values_to = "thermo_score"
  ) |>
  pivot_longer(
    cols = matches("^ext_q_thermo_[0-9]+_pf_name$"),
    names_to = "party_slot",
    values_to = "thermo_party"
  ) |>
  filter(
    str_extract(thermo_slot, "[0-9]+") == str_extract(party_slot, "[0-9]+")
  ) |>
  select(
    meta_pid,
    der_partisan_type,
    der_partisan_anchor,
    thermo_party,
    thermo_score
  ) |>
  filter(!is.na(thermo_score), !is.na(thermo_party)) |>
  mutate(thermo_score = thermo_score / 10)

# calculate individual level AP
api_individual <- thermo_long |>
  mutate(
    ingroup = thermo_party == der_partisan_anchor
  ) |>
  group_by(meta_pid, der_partisan_type) |>
  summarise(
    mean_Co = mean(thermo_score[ingroup], na.rm = TRUE),
    mean_Out = mean(thermo_score[!ingroup], na.rm = TRUE),
    api = mean_Co - mean_Out,
    n_Co = sum(ingroup),
    n_Out = sum(!ingroup),
    .groups = "drop"
  ) |>
  filter(n_Co > 0, n_Out > 0)


pooled_ap_thermo <- api_individual |>
  group_by(der_partisan_type) |>
  summarise(
    diff_mean = mean(api),
    sd_diff = sd(api),
    n_diff = n(),
    se_diff = sd_diff / sqrt(n_diff),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff,
    .groups = "drop"
  ) |>
  mutate(
    measure = "Thermometer",
    index = "API",
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )


total_ap_thermo <- api_individual |>
  summarise(
    diff_mean = mean(api),
    sd_diff = sd(api),
    n_diff = n(),
    se_diff = sd_diff / sqrt(n_diff),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff,
    .groups = "drop"
  ) |>
  mutate(der_partisan_type = "Total") |>
  relocate(der_partisan_type, .before = diff_mean)

pooled_ap_thermo <- bind_rows(pooled_ap_thermo, total_ap_thermo)

```


```{r}
#| label: total-sample-wagner-mean-distance

# calculate individual level AP
meandist_individual <- thermo_long |>
  group_by(meta_pid, der_partisan_type) |>
  summarise(
    mean_like = mean(thermo_score, na.rm = TRUE),
    ap = sqrt(mean((thermo_score - mean_like)^2, na.rm = TRUE)),
    .groups = "drop"
  )


pooled_meandist_thermo <- meandist_individual |>
  group_by(der_partisan_type) |>
  summarise(
    diff_mean = mean(ap),
    sd_diff = sd(ap),
    n_diff = n(),
    se_diff = sd_diff / sqrt(n_diff),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff,
    .groups = "drop"
  ) |>
  mutate(
    measure = "Thermometer",
    index = "Mean Distance",
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )


total_meandist_thermo <- meandist_individual |>
  summarise(
    diff_mean = mean(ap),
    sd_diff = sd(ap),
    n_diff = n(),
    se_diff = sd_diff / sqrt(n_diff),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff,
    .groups = "drop"
  ) |>
  mutate(
    der_partisan_type = "Total",
    measure = "Thermometer",
    index = "Mean Distance",
  ) |>
  relocate(der_partisan_type, .before = diff_mean)

pooled_ap_thermo <- bind_rows(pooled_ap_thermo, total_ap_thermo)

```


```{r}
#| label: total-sample-wagner-spread

spread_individual <- thermo_long |>
  group_by(meta_pid, der_partisan_type) |>
  summarise(
    likemax = max(thermo_score, na.rm = TRUE),
    spread = sqrt(mean(
      (thermo_score[thermo_score != likemax] - likemax)^2,
      na.rm = TRUE
    ))
  )

```


# Figure

```{r}
#| label: fig-eu25-ap-comparison

```

The full **Affective Polarization Index** (Reiljan 2020):

$$
\text{API} = \sum_{n=1}^{N} \left[ \sum_{\substack{m = 1\\ m \neq n}}^{N} \left( (Like_n - Like_m) \times \left(\frac{\text{Vote share}_{m}}{1 - \text{Vote share}_{n}} \right) \right) \times \text{Vote share}_n \right]
$$


# Session Info

```{r}
#| label: session-info

session_info()
```


# Render Time

```{r}
#| label: render-time

end_time <- Sys.time()

rendering_time <- end_time - start_time

message(paste(
  "Document rendered in:",
  round(as.numeric(rendering_time, units = "secs"), 2),
  "seconds.
"
))
```


  
