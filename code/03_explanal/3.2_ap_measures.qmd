---
title: |
  Code Notebook 3.2
subtitle: |
  AP Measures
date: last-modified
date-format: MMMM D, YYYY
format:
  html:
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
execute:
  echo: true
  warning: true
  eval: true
  message: true
---

# Setup

```{r}
#| label: setup

# To track render duration
start_time <- Sys.time()

# set width of console output
options(width = 80)


# Install and load required packages
p_required <- c(
  "tidyverse",
  "here",
  "sessioninfo"
)
packages <- rownames(installed.packages())
p_to_install <- p_required[!(p_required %in% packages)]
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_required, require, character.only = TRUE)
rm(p_required, p_to_install, packages)
```

# Load Data

```{r}
#| label: load-data

eu25games2019 <- readRDS(
  file = here(
    "data",
    "03_final",
    "eu25games2019.rds"
  )
)
```

# Overview of Measures

For our behavioral experiment, we conceptually draw from Reiljan's API.
Formally, we define AP as the difference in tokens allocated to the ingroup, minus the average number of tokens allocated to all outgroups. 

Weighted and unweighted

For the thermometer score, we calculate three measures, each weighted and unweighted:

Reiljan API
Wagner Mean Distance
Wagner Spread of Scores

We compare the levels across identifiers, voters (without identity) and nonpartisans (Wagner)

# Party sizes (for weighting)

What to use, empirical distributions in sample (id/vote?) or electoral vote share in 2019? Both?

```{r}
#| label: party-shares-vote-variable

# relative (reported) vote shares
votes_per_country <- eu25games2019 |>
  select(
    meta_country,
    meta_pid,
    der_vote_combined_name
  ) |>
  distinct(meta_pid, .keep_all = T) |>
  filter(
    der_vote_combined_name != "dont-know" &
      der_vote_combined_name != "other"
  ) |>
  group_by(meta_country, der_vote_combined_name) |>
  count(der_vote_combined_name) |>
  ungroup() |>
  group_by(meta_country) |>
  summarise(
    abs_vote = sum(n)
  )

votes_per_party <- eu25games2019 |>
  select(
    meta_country,
    meta_pid,
    der_vote_combined_name
  ) |>
  distinct(meta_pid, .keep_all = T) |>
  filter(
    der_vote_combined_name != "dont-know" &
      der_vote_combined_name != "other"
  ) |>
  group_by(meta_country, der_vote_combined_name) |>
  count(der_vote_combined_name) |>
  ungroup()

votes_per_party <- votes_per_party |>
  left_join(
    votes_per_country,
    by = join_by(meta_country)
  )

votes_per_party <- votes_per_party |>
  mutate(
    der_anchor_vote_share = n / abs_vote
  )

eu25games2019 <- eu25games2019 |>
  left_join(
    (votes_per_party |>
      select(
        der_vote_combined_name,
        der_anchor_vote_share
      )),
    by = join_by(der_partisan_anchor == der_vote_combined_name)
  )
```

# Target Table (Pooled Descriptive Analyses)

What I want is a tibble in the format (or do I?)

| Measurement | measure | weighted | der_partisan_type | ap | ci_low | ci_high | 
|:--|:--------|:---------|:------------------|---:|-------:|--------:|
| Behavioral | API | N | Explicit | X | X | X |
| Behavioral | API  | N | Implicit | X | X | X |
| Behavioral | API  | N | Total | X | X | X |
| Behavioral | API  | Y | Explicit | X | X | X |
| Behavioral | API  | Y | Implicit | X | X | X |
| Behavioral | API  | Y | Total | X | X | X |
| Attitudinal | API  | N | Explicit | X | X | X |
| Attitudinal | API  | N | Implicit | X | X | X |
| Attitudinal | API  | N | Total | X | X | X |
| Attitudinal | API  | Y | Explicit | X | X | X |
| Attitudinal | API  | Y | Implicit | X | X | X |
| Attitudinal | API  | Y | Total | X | X | X |
| Attitudinal | Mean Dist. | N | Explicit | X | X | X |
| Attitudinal | Mean Dist. | N | Implicit | X | X | X |
| Attitudinal | Mean Dist. | N | None | X | X | X |
| Attitudinal | Mean Dist. | N | Total | X | X | X |
| Attitudinal | Mean Dist. | Y | Explicit | X | X | X |
| Attitudinal | Mean Dist. | Y | Implicit | X | X | X |
| Attitudinal | Mean Dist. | Y | None | X | X | X |
| Attitudinal | Mean Dist. | Y | Total | X | X | X |
| Attitudinal | Spread | N | Explicit | X | X | X |
| Attitudinal | Spread | N | Implicit | X | X | X |
| Attitudinal | Spread | N | None | X | X | X |
| Attitudinal | Spread | N | Total | X | X | X |
| Attitudinal | Spread | Y | Explicit | X | X | X |
| Attitudinal | Spread | Y | Implicit | X | X | X |
| Attitudinal | Spread | Y | None | X | X | X |
| Attitudinal | Spread | Y | Total | X | X | X |

# Aggregated AP: Token Allocation

We measure affective polarization as the difference in expected token allocations to co-partisans and out-partisans. Expectations are taken over all conjoint profiles presented to respondents, such that the out-partisan category averages across all non-anchor parties. This operationalization is conceptually equivalent to Reiljan's affective polarization index (API), adapted to behavioral outcomes.

$$
\text{AP} = \mathbb{E}(\text{Token} \mid \text{Co}) - \mathbb{E}(\text{Token} \mid \text{Out})
$$ {#eq-eu25-ap-cj}

```{r}
#| label: eu25-ap-cj-unweighted

pooled_ap_cj <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type)
  ) |>
  group_by(der_partisan_type, der_partisan_relationship) |>
  summarise(
    mean = mean(cj_token),
    sd = sd(cj_token),
    n = n(),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = c(mean, sd, n)
  ) |>
  mutate(
    ap = mean_Co - mean_Out,
    se = sqrt(sd_Co^2 / n_Co + sd_Out^2 / n_Out),
    ci_low = ap - 1.96 * se,
    ci_high = ap + 1.96 * se,
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )


total_pooled_ap_cj <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type)
  ) |>
  group_by(der_partisan_relationship) |>
  summarise(
    mean = mean(cj_token),
    sd = sd(cj_token),
    n = n(),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = c(mean, sd, n)
  ) |>
  mutate(
    ap = mean_Co - mean_Out,
    se = sqrt(sd_Co^2 / n_Co + sd_Out^2 / n_Out),
    ci_low = ap - 1.96 * se,
    ci_high = ap + 1.96 * se
  ) |>
  mutate(der_partisan_type = "Total") |>
  relocate(der_partisan_type, .before = mean_Co)

pooled_ap_cj <- pooled_ap_cj |>
  bind_rows(total_pooled_ap_cj) |>
  mutate(measure = "Token")

pooled_ap_cj <- pooled_ap_cj |>
  select(
    der_partisan_type,
    ap,
    ci_low,
    ci_high
  ) |>
  mutate(
    measurement = "Behavioral",
    measure = "API",
    outcome = "Token",
    weighted = 0,
  )
```

To account for cross-national differences in party system composition, we compute party-specific affective polarization within each country and weight these differences by parties' empirical vote shares in our data. Party weights sum to one within countries, ensuring that affective polarization reflects the relative electoral importance of parties in the national party system.

European affective polarization is obtained by aggregating country-level affective polarization scores. Each country contributes equally to the European estimate, preventing countries with larger samples or more fragmented party systems from exerting disproportionate influence.

$$
\text{AP}_{c}
=
\sum_{p \in c}
w_{pc}
\, \text{AP}_{pc},
\qquad
\sum_{p \in c} w_{pc} = 1
$$ {#eq-eu25-ap-country-weighted}

$$
\text{AP}_{EU}
=
\frac{1}{C}
\sum_{c=1}^{C}
\text{AP}_{c}
$$ {#eq-eu25-ap-europe}



```{r}
#| label: eu25-ap-cj-weighted

ap_country_party <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type),
    !is.na(der_anchor_vote_share)
  ) |>
  group_by(
    meta_country,
    der_partisan_type,
    der_partisan_anchor,
    der_partisan_relationship
  ) |>
  summarise(
    mean = mean(cj_token),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = mean
  ) |>
  mutate(
    ap_party = Co - Out
  )

ap_country_weighted <- eu25games2019 |>
  distinct(
    meta_country,
    der_partisan_anchor,
    der_anchor_vote_share
  ) |>
  right_join(
    ap_country_party,
    by = c("meta_country", "der_partisan_anchor")
  ) |>
  group_by(meta_country, der_partisan_type) |>
  summarise(
    ap_country = sum(ap_party * der_anchor_vote_share, na.rm = TRUE),
    .groups = "drop"
  )

ap_europe <- ap_country_weighted |>
  group_by(der_partisan_type) |>
  summarise(
    ap = mean(ap_country),
    se = sd(ap_country) / sqrt(n()),
    ci_low = ap - 1.96 * se,
    ci_high = ap + 1.96 * se,
    .groups = "drop"
  ) |>
  mutate(
    measurement = "Behavioral",
    measure = "API",
    outcome = "Token",
    weighted = 1,
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )

# Again for total AP (no distinguishing type) ----------------------------------
ap_country_party_total <- eu25games2019 |>
  filter(
    der_partisan_relationship %in% c("Co", "Out"),
    !is.na(der_partisan_type),
    !is.na(der_anchor_vote_share)
  ) |>
  group_by(
    meta_country,
    der_partisan_anchor,
    der_partisan_relationship
  ) |>
  summarise(
    mean = mean(cj_token),
    .groups = "drop"
  ) |>
  pivot_wider(
    names_from = der_partisan_relationship,
    values_from = mean
  ) |>
  mutate(
    ap_party = Co - Out
  )

ap_country_weighted_total <- eu25games2019 |>
  distinct(
    meta_country,
    der_partisan_anchor,
    der_anchor_vote_share
  ) |>
  right_join(
    ap_country_party_total,
    by = c("meta_country", "der_partisan_anchor")
  ) |>
  group_by(meta_country) |>
  summarise(
    ap_country = sum(ap_party * der_anchor_vote_share, na.rm = TRUE),
    .groups = "drop"
  )

ap_europe_total <- ap_country_weighted_total |>
  summarise(
    ap = mean(ap_country),
    se = sd(ap_country) / sqrt(n()),
    ci_low = ap - 1.96 * se,
    ci_high = ap + 1.96 * se,
    .groups = "drop"
  ) |>
  mutate(
    measurement = "Behavioral",
    measure = "API",
    outcome = "Token",
    weighted = 1,
    der_partisan_type = "Total"
  ) |>
  select(
    -se
  )

pooled_ap_cj <- pooled_ap_cj |>
  bind_rows(ap_europe, ap_europe_total)
```


# Aggregated AP: Thermometer Scores

There are three main operationalization strategies applied in European AP studies: Reiljan's API, Wagner's mean distance and Wagner's average spread.

I am starting simple, with unweighted variants of all three, beginning with Reiljan's API.

```{r}
#| label: eu25-reiljan-api

# turn thermoscores to long format
thermo_long <- eu25games2019 |>
  select(
    meta_pid,
    der_partisan_type,
    der_partisan_anchor,
    starts_with("q_thermo_"),
    starts_with("ext_q_thermo_")
  ) |>
  pivot_longer(
    cols = matches("^q_thermo_[0-9]+$"),
    names_to = "thermo_slot",
    values_to = "thermo_score"
  ) |>
  pivot_longer(
    cols = matches("^ext_q_thermo_[0-9]+_pf_name$"),
    names_to = "party_slot",
    values_to = "thermo_party"
  ) |>
  filter(
    str_extract(thermo_slot, "[0-9]+") == str_extract(party_slot, "[0-9]+")
  ) |>
  select(
    meta_pid,
    der_partisan_type,
    der_partisan_anchor,
    thermo_party,
    thermo_score
  ) |>
  filter(!is.na(thermo_score), !is.na(thermo_party)) |>
  mutate(thermo_score = thermo_score / 10)

# calculate individual level AP
api_individual <- thermo_long |>
  mutate(
    ingroup = thermo_party == der_partisan_anchor
  ) |>
  group_by(meta_pid, der_partisan_type) |>
  summarise(
    mean_Co = mean(thermo_score[ingroup], na.rm = TRUE),
    mean_Out = mean(thermo_score[!ingroup], na.rm = TRUE),
    api = mean_Co - mean_Out,
    n_Co = sum(ingroup),
    n_Out = sum(!ingroup),
    .groups = "drop"
  ) |>
  filter(n_Co > 0, n_Out > 0)


pooled_ap_thermo <- api_individual |>
  group_by(der_partisan_type) |>
  summarise(
    ap = mean(api),
    sd_ap = sd(api),
    n_ap = n(),
    se_ap = sd_ap / sqrt(n_ap),
    ci_low = ap - 1.96 * se_ap,
    ci_high = ap + 1.96 * se_ap,
    .groups = "drop"
  ) |>
  mutate(
    measurement = "Attitudinal",
    measure = "API",
    outcome = "Thermo Score",
    weighted = 0,
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )


total_ap_thermo <- api_individual |>
  summarise(
    ap = mean(api),
    sd_ap = sd(api),
    n_ap = n(),
    se_ap = sd_ap / sqrt(n_ap),
    ci_low = ap - 1.96 * se_ap,
    ci_high = ap + 1.96 * se_ap,
    .groups = "drop"
  ) |>
  mutate(
    measurement = "Attitudinal",
    measure = "API",
    outcome = "Thermo Score",
    weighted = 0,
    der_partisan_type = "Total"
  ) |>
  relocate(der_partisan_type, .before = ap)

pooled_ap_thermo <- bind_rows(pooled_ap_thermo, total_ap_thermo) |>
  select(
    -sd_ap,
    -n_ap,
    -se_ap
  )

```


```{r}
#| label: total-sample-wagner-mean-distance

# calculate individual level AP
meandist_individual <- thermo_long |>
  group_by(meta_pid, der_partisan_type) |>
  summarise(
    mean_like = mean(thermo_score, na.rm = TRUE),
    ap = sqrt(mean((thermo_score - mean_like)^2, na.rm = TRUE)),
    .groups = "drop"
  )


pooled_meandist_thermo <- meandist_individual |>
  group_by(der_partisan_type) |>
  summarise(
    diff_mean = mean(ap),
    sd_ap = sd(ap),
    n_ap = n(),
    se_ap = sd_ap / sqrt(n_ap),
    ci_low = diff_mean - 1.96 * se_ap,
    ci_high = diff_mean + 1.96 * se_ap,
    .groups = "drop"
  ) |>
  mutate(
    measure = "Thermometer",
    index = "Mean Distance",
    der_partisan_type = case_when(
      der_partisan_type == 1 ~ "Explicit",
      der_partisan_type == 0 ~ "Implicit",
      .default = NA
    )
  )


total_meandist_thermo <- meandist_individual |>
  summarise(
    diff_mean = mean(ap),
    sd_diff = sd(ap),
    n_diff = n(),
    se_diff = sd_diff / sqrt(n_diff),
    ci_low = diff_mean - 1.96 * se_diff,
    ci_high = diff_mean + 1.96 * se_diff,
    .groups = "drop"
  ) |>
  mutate(
    der_partisan_type = "Total",
    measure = "Thermometer",
    index = "Mean Distance",
  ) |>
  relocate(der_partisan_type, .before = diff_mean)

pooled_ap_thermo <- bind_rows(pooled_ap_thermo, total_ap_thermo)

```


```{r}
#| label: total-sample-wagner-spread

spread_individual <- thermo_long |>
  group_by(meta_pid, der_partisan_type) |>
  summarise(
    likemax = max(thermo_score, na.rm = TRUE),
    spread = sqrt(mean(
      (thermo_score[thermo_score != likemax] - likemax)^2,
      na.rm = TRUE
    ))
  )

```


# Figure

```{r}
#| label: fig-eu25-ap-comparison

```

The full **Affective Polarization Index** (Reiljan 2020):

$$
\text{API} = \sum_{n=1}^{N} \left[ \sum_{\substack{m = 1\\ m \neq n}}^{N} \left( (Like_n - Like_m) \times \left(\frac{\text{Vote share}_{m}}{1 - \text{Vote share}_{n}} \right) \right) \times \text{Vote share}_n \right]
$$


# Session Info

```{r}
#| label: session-info

session_info()
```


# Render Time

```{r}
#| label: render-time

end_time <- Sys.time()

rendering_time <- end_time - start_time

message(paste(
  "Document rendered in:",
  round(as.numeric(rendering_time, units = "secs"), 2),
  "seconds.
"
))
```


  
