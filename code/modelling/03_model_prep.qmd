---
title: |
  Code Notebook
subtitle: |
  How does reported partisan attachement influence affective polarization?: A comparative study of 25 European democracies
author:
  - name: Tristan Muno
    email: tristan.muno@uni-mannheim.de
    affiliations:
      - name: University of Mannheim
        department: School of Social Sciences
date: last-modified
date-format: MMMM D, YYYY
format:
  html:
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
execute:
  echo: true
  warning: true
  eval: true
  message: true
---

# Setup

```{r}
#| label: setup

# To track render duration
start_time <- Sys.time()

# set width of console output
options(width = 80)


# Install and load required packages
p_required <- c(
  "tidyverse",
  "here",
  "lme4",
  "brms",
  "sessioninfo"
)
packages <- rownames(installed.packages())
p_to_install <- p_required[!(p_required %in% packages)]
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_required, require, character.only = TRUE)
rm(p_required, p_to_install, packages)
```

```{r}
#| label: load-data

load(
  here("data", "02_processed", "df_modeldata.RData")
)
```



# Model Formula

```{r}
#| label: model-formulas

formula_naive <-
  # outcome: tokens allocated --------------------------------------------------
  cj_token ~
    1 + # global intercept

    # main variables of interest -----------------------------------------------
    der_partisan_type +
    der_partisan_relationship +
    der_partisan_type * der_partisan_relationship +

    # conjoint controls Z ------------------------------------------------------
    cj_age_en +
    cj_class_en +
    cj_sex_en +
    cj_reli_en +
    cj_eupos_shown + # eupos trmnt only in dictator
    meta_round + # round of game
    meta_wave # wave of survey


formula_naive_covariates <-
  # outcome: tokens allocated --------------------------------------------------
  cj_token ~
    1 + # global intercept

    # main variables of interest -----------------------------------------------
    der_partisan_type +
    der_partisan_relationship +
    der_partisan_type * der_partisan_relationship +

    # conjoint controls Z ------------------------------------------------------
    cj_age_en +
    cj_class_en +
    cj_sex_en +
    cj_reli_en +
    cj_eupos_shown + # eupos trmnt only in dictator
    meta_round + # round of game
    meta_wave + # wave of survey

    # confounding variables C --------------------------------------------------
    q_lrpos2_z +
    q_eupos2_z +
    q_econ_nativism_z +
    q_cult_nativism_z +
    q_religion_en +
    q_satis_demo_country_z +
    q_understand_nat_pol_z +
    q_understand_eu_pol_z +
    q_parties_harm_z +
    q_officials_talk_action_z +
    q_politics_good_evil_z +
    q_people_unaware_z +
    q_leaders_educated_z +
    q_expert_decisions_z +
    q_listen_other_groups_z +
    q_democracy_compromise_z +
    q_interest_pol_country_z +
    q_interest_pol_eu_z +
    q_edu_z +
    q_perc_class +
    q_eval_finance_household_z +
    q_eval_job_z +
    q_eval_econ_country_z +
    q_eval_econ_eur_z +
    q_gender +
    q_age_z +
    q_rural_urban +
    q_risk_taking_z +
    q_future_discount_z

formula_base <-
  # outcome: tokens allocated --------------------------------------------------
  cj_token ~
    1 + # global intercept

    # main variables of interest -----------------------------------------------
    der_partisan_type +
    der_partisan_relationship +
    der_partisan_type * der_partisan_relationship +

    # conjoint controls Z ------------------------------------------------------
    cj_age_en +
    cj_class_en +
    cj_sex_en +
    cj_reli_en +
    cj_eupos_shown + # eupos trmnt only in dictator
    meta_round + # round of game
    meta_wave + # wave of survey

    # random intercept and slope components ------------------------------------
    # Level 4: Country (c) - Correlated Intercept and Slopes
    (1 + der_partisan_type + der_partisan_relationship | meta_country) +

    # Level 3: Partisan Anchor (a) nested in Country (c) - Correlated Intercept and Slopes
    (1 +
      der_partisan_type +
      der_partisan_relationship |
      meta_country:der_partisan_anchor) +

    # Level 2: Respondent (i) nested in (a:c) - Intercept only
    (1 | meta_pid)


formula_covariates <-
  # outcome: tokens allocated --------------------------------------------------
  cj_token ~
    1 + # global intercept

    # main variables of interest -----------------------------------------------
    der_partisan_type +
    der_partisan_relationship +
    der_partisan_type * der_partisan_relationship +

    # conjoint controls Z ------------------------------------------------------
    cj_age_en +
    cj_class_en +
    cj_sex_en +
    cj_reli_en +
    cj_eupos_shown + # eupos trmnt only in dictator
    meta_round + # round of game
    meta_wave + # wave of survey

    # confounding variables C --------------------------------------------------
    q_lrpos2_z +
    q_eupos2_z +
    q_econ_nativism_z +
    q_cult_nativism_z +
    q_religion_en +
    q_satis_demo_country_z +
    q_understand_nat_pol_z +
    q_understand_eu_pol_z +
    q_parties_harm_z +
    q_officials_talk_action_z +
    q_politics_good_evil_z +
    q_people_unaware_z +
    q_leaders_educated_z +
    q_expert_decisions_z +
    q_listen_other_groups_z +
    q_democracy_compromise_z +
    q_interest_pol_country_z +
    q_interest_pol_eu_z +
    q_edu_z +
    q_perc_class +
    q_eval_finance_household_z +
    q_eval_job_z +
    q_eval_econ_country_z +
    q_eval_econ_eur_z +
    q_gender +
    q_age_z +
    q_rural_urban +
    q_risk_taking_z +
    q_future_discount_z +

    # random intercept and slope components ------------------------------------
    # Level 4: Country (c) - Correlated Intercept and Slopes
    (1 + der_partisan_type + der_partisan_relationship | meta_country) +

    # Level 3: Partisan Anchor (a) nested in Country (c) - Correlated Intercept and Slopes
    (1 +
      der_partisan_type +
      der_partisan_relationship |
      meta_country:der_partisan_anchor) +

    # Level 2: Respondent (i) nested in (a:c) - Intercept only
    (1 | meta_pid)

bformula_naive <- bf(formula_naive)
bformula_naive_covariates <- bf(formula_naive_covariates)
bformula_base <- bf(formula_base)
bformula_covariates <- bf(formula_covariates)
```

```{r, message = NA}
#| label: lme4-fits

## Naive models
message(paste("Fitting lme4_dict_naive at", Sys.time()))
lme4_fit_dict_naive <- lmer(
  formula = formula_naive,
  data = df_modelvars |>
    filter(meta_game == "dict")
)

message(paste("Fitting lme4_fit_trust_naive at", Sys.time()))
lme4_fit_trust_naive <- lmer(
  formula = formula_naive,
  data = df_modelvars |>
    filter(meta_game == "trust")
)

## Naive covariate models
message(paste("Fitting lme4_dict_naive at", Sys.time()))
lme4_fit_dict_naive_cov <- lmer(
  formula = formula_naive_covariates,
  data = df_modelvars |>
    filter(meta_game == "dict")
)

message(paste("Fitting lme4_fit_trust_naive at", Sys.time()))
lme4_fit_trust_naive_cov <- lmer(
  formula = formula_naive_covariates,
  data = df_modelvars |>
    filter(meta_game == "trust")
)

## BASE MODELS
message(paste("Fitting lme4_dict_base at", Sys.time()))
lme4_fit_dict_base <- lmer(
  formula = formula_base,
  data = df_modelvars |>
    filter(meta_game == "dict")
)

message(paste("Fitting lme4_fit_trust_base at", Sys.time()))
lme4_fit_trust_base <- lmer(
  formula = formula_base,
  data = df_modelvars |>
    filter(meta_game == "trust")
)

## Covariate models
message(paste("Fitting lme4_fit_dict_cov at", Sys.time()))
lme4_fit_dict_cov <- lmer(
  formula = formula_covariates,
  data = df_modelvars |>
    filter(meta_game == "dict")
)

message(paste("Fitting lme4_fit_trust_cov at", Sys.time()))
lme4_fit_trust_cov <- lmer(
  formula = formula_covariates,
  data = df_modelvars |>
    filter(meta_game == "trust")
)

```


# Model Starting Values

```{r, message = NA}
#| label: initial-values-function

# Convert lmer object into brms init list
lmer_to_brms_inits <- function(lmer_model, noise_sd, n_chains) {
  # --- 1. FIXED EFFECTS -------------------------------------------------------
  fe <- fixef(lmer_model)
  names(fe) <- paste0("b_", names(fe))

  # --- 2. RANDOM EFFECTS ------------------------------------------------------
  vc <- VarCorr(lmer_model)
  re_list <- list()

  for (g in names(vc)) {
    mat <- as.matrix(vc[[g]])
    sd_vec <- sqrt(diag(mat))

    # SDs
    for (i in seq_along(sd_vec)) {
      parname <- paste0("sd_", g, "__", colnames(mat)[i])
      re_list[[parname]] <- sd_vec[i]
    }

    # Correlations
    if (ncol(mat) > 1) {
      cor_mat <- cov2cor(mat)
      for (i in 2:ncol(cor_mat)) {
        for (j in 1:(i - 1)) {
          parname <- paste0(
            "cor_",
            g,
            "__",
            colnames(cor_mat)[i],
            "__",
            colnames(cor_mat)[j]
          )
          re_list[[parname]] <- cor_mat[i, j]
        }
      }
    }
  }

  # --- 3. RESIDUAL SD ---------------------------------------------------------
  resid_sd <- sigma(lmer_model)

  # --- Base init list (the same for all chains before jittering) ---
  base_init <- c(as.list(fe), re_list, list(sigma = resid_sd))

  # --- Helper: add noise ---
  jitter_list <- function(x, noise_sd) {
    lapply(x, function(v) {
      if (is.numeric(v)) {
        return(v + rnorm(1, 0, noise_sd))
      } else {
        return(v)
      }
    })
  }

  # --- Return nested list: one list of inits per chain ---
  init_chains <- replicate(
    n_chains,
    jitter_list(base_init, noise_sd),
    simplify = FALSE
  )

  return(init_chains)
}


```

# Model Settings

```{r, message = NA}
#| label: stan-settings

Sys.setenv(RSTUDIO = 1)

n_chains <- 4
n_iter <- 5000
n_burnin <- 2000
n_cores <- 4

# Weakly informative priors
priors <- c(
  prior(normal(0, 2), class = "b"), # fixed slopes
  prior(normal(5, 2), class = "Intercept"), # global intercept
  prior(student_t(3, 0, 1), class = "sd"), # RE SDs
  prior(student_t(3, 0, 2), class = "sigma") # residual SD
)

# Compile
# models
# without
# sampling
compiled_base_d <- brm(
  formula = bformula_base,
  data = df_modelvars |> filter(meta_game == "dict"),
  family = gaussian(),
  prior = priors,
  chains = 0,
  init = lmer_to_brms_inits(
    lme4_fit_dict_base,
    noise_sd = 0.001,
    n_chains = n_chains
  )
)

compiled_base_t <- brm(
  formula = bformula_base,
  data = df_modelvars |> filter(meta_game == "trust"),
  family = gaussian(),
  prior = priors,
  chains = 0,
  init = lmer_to_brms_inits(
    lme4_fit_trust_base,
    noise_sd = 0.001,
    n_chains = n_chains
  )
)

compiled_cov_d <- brm(
  formula = bformula_covariates,
  data = df_modelvars |> filter(meta_game == "dict"),
  family = gaussian(),
  prior = priors,
  chains = 0,
  init = lmer_to_brms_inits(
    lme4_fit_dict_cov,
    noise_sd = 0.001,
    n_chains = n_chains
  )
)

compiled_cov_t <- brm(
  formula = bformula_covariates,
  data = df_modelvars |> filter(meta_game == "trust"),
  family = gaussian(),
  prior = priors,
  chains = 0,
  init = lmer_to_brms_inits(
    lme4_fit_trust_cov,
    noise_sd = 0.001,
    n_chains = n_chains
  )
)
```

# Saving

```{r, message = NA}
#| label: save-compiled-models-and-data

# Save compiled objects for later
save(
  compiled_base_d,
  file = here("data", "02_processed", "models", "compile_base_d.RData")
)
save(
  compiled_base_t,
  file = here("data", "02_processed", "models", "compile_base_t.RData")
)
save(
  compiled_cov_d,
  file = here("data", "02_processed", "models", "compile_cov_d.RData")
)
save(
  compiled_cov_t,
  file = here("data", "02_processed", "models", "compile_cov_t.RData")
)

```

# Session Info

```{r}
#| label: session-info

session_info()
```


# Render Time

```{r}
#| label: render-time

end_time <- Sys.time()

rendering_time <- end_time - start_time

message(paste(
  "Document rendered in:",
  round(as.numeric(rendering_time, units = "secs"), 2),
  "seconds.
"
))
```


  
