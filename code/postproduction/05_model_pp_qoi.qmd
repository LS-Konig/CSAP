---
title: |
  Code Notebook
subtitle: |
  How does reported partisan attachement influence affective polarization?: A comparative study of 25 European democracies
author:
  - name: Tristan Muno
    email: tristan.muno@uni-mannheim.de
    affiliations:
      - name: University of Mannheim
        department: School of Social Sciences
date: last-modified
date-format: MMMM D, YYYY
format:
  html:
    toc: true
    code-fold: true
    code-tools: true
    embed-resources: true
execute:
  echo: true
  warning: true
  eval: true
  message: true
---

# Setup

```{r}
#| label: setup

# To track render duration
start_time <- Sys.time()

# set width of console output
# options(width = 80)

# Install and load required packages
p_required <- c(
  "tidyverse",
  "here",
  "brms",
  "tidybayes",
  "ggpubr",
  "patchwork",
  "sessioninfo"
)
packages <- rownames(installed.packages())
p_to_install <- p_required[!(p_required %in% packages)]
if (length(p_to_install) > 0) {
  install.packages(p_to_install)
}
sapply(p_required, require, character.only = TRUE)
rm(p_required, p_to_install, packages)
```

# Load models

```{r}
#| label: load-models

load(here("data", "03_final", "models", "bfit_naive_d.RData"))

load(here("data", "03_final", "models", "bfit_naive_t.RData"))

load(here("data", "03_final", "models", "bfit_naive_cov_d.RData"))

load(here("data", "03_final", "models", "bfit_naive_cov_t.RData"))

load(here("data", "03_final", "models", "bfit_base_d.RData"))

load(here("data", "03_final", "models", "bfit_base_t.RData"))

load(here("data", "03_final", "models", "bfit_cov_d.RData"))

load(here("data", "03_final", "models", "bfit_cov_t.RData"))

```

# Expected values simulations

We want for each of the 4 models 6 QoI (24 in total):

EV(Y|co & impl); EV(Y|co &expl)
EV(Y|out & impl); EV(Y|out &expl)
EV(Y|none & impl); EV(Y|none &expl)

and then for comparative * 25 countries:
EV(Y|co & impl & country[i]); EV(Y|co &expl& country[i])
EV(Y|out & impl& country[i]); EV(Y|out &expl& country[i])
EV(Y|none & impl& country[i]); EV(Y|none &expl& country[i])

So, it makes most sense to create a function that takes newdata grid as input and outputs EV, ideally with observed values approach.

Pseude-code:
1. funtion to generate newdata grid, 
    - input: model (to extract data), T and R value
    - output newdata grid
2. function to estimate EVs
    - input: model (for effects), newdata
    - output: 6 EV vectors
3. function to estimate QoIs
    - input: EV vectors
    - output: AP (2x), IF (2x), OD (2x), CATE_AP, CATE_IF, CATE_OD
4- function to ggplot main effects
    - input: QoIs
    - output: ggplot object (exact structure tbto)


## Preparing the functions, the pipeline

### Step 1: Generating newdata 

Following conceptual observed

```{r}
#| label: create-newdata-function

# 1. Function to generate the APE newdata grid (T_i x R_ri combinations)
# ----------------------------------------------------------------------

#' Creates the required 'newdata' grid for the Observed Value Approach (APE)
#'
#' Generates 6 copies of the original data (all combinations of Partisan Type T
#' and Partisan Relationship R). The function can operate in two modes:
#'
#' **(1) Pooled Mode (default)**
#' Returns 6 tibbles, each containing the *full dataset* with T and R set to one
#' of the 6 focal combinations.
#'
#' **(2) Country-Specific Mode (`by_country = TRUE`)**
#' Automatically splits the model data by country and returns a nested list:
#' `newdata_list[["CountryName"]][["T1_RCo"]]`, each containing a *country-specific*
#' subset of the original data with T and R fixed to the focal values.
#'
#' This structure is designed for `brms::epred()` calls for either pooled or
#' country-level APE computation.
#'
#' @param bfit_model The fitted brms model object (must contain the model data).
#' @param focal_T Vector of T values (e.g., c(0, 1)).
#' @param focal_R Vector of R factor levels (e.g., c("Co", "Out", "None")).
#' @param by_country Logical. If TRUE, produces newdata grids for each country separately.
#' @param country_var Character. Name of the country variable in the data (default `"country"`).
#'
#' @return
#' - If `by_country = FALSE`: A list of 6 tibbles (full data each).
#' - If `by_country = TRUE`: A nested list of lists:
#'     `list[["Country"]][["T_val_R_val"]] = tibble`.
#' @export
create_ape_newdata <- function(
  bfit_model,
  focal_T = c(0, 1),
  focal_R = c("Co", "Out", "None"),
  by_country = FALSE,
  country_var = "country"
) {
  original_data <- bfit_model[["data"]] |> as_tibble()

  # Ensure 'der_partisan_relationship' is a factor and levels are consistent
  R_levels <- levels(original_data$der_partisan_relationship)
  if (is.null(R_levels) || length(R_levels) == 0) {
    stop(
      "Column 'der_partisan_relationship' must be a factor in the model data."
    )
  }

  # All 6 T × R combinations
  focal_combinations <- expand_grid(T_val = focal_T, R_val = focal_R)

  # ----------------------------------------------------------------------
  # OPTION 1: POOLED ANALYSIS (default)
  # ----------------------------------------------------------------------
  if (!by_country) {
    newdata_list <- list()

    for (i in 1:nrow(focal_combinations)) {
      T_set <- focal_combinations$T_val[i]
      R_set <- focal_combinations$R_val[i]

      new_df <- original_data |>
        mutate(
          der_partisan_type = T_set,
          der_partisan_relationship = factor(R_set, levels = R_levels)
        )

      condition_id <- paste0("T", T_set, "_R", R_set)
      newdata_list[[condition_id]] <- new_df
    }

    return(newdata_list)
  }

  # ----------------------------------------------------------------------
  # OPTION 2: COUNTRY-SPECIFIC ANALYSIS
  # ----------------------------------------------------------------------
  if (!country_var %in% names(original_data)) {
    stop(paste0(
      "Country variable '",
      country_var,
      "' not found in model data."
    ))
  }

  country_values <- unique(original_data[[country_var]])

  newdata_country_list <- list()

  for (country in country_values) {
    data_country <- original_data |>
      filter(.data[[country_var]] == country)

    country_list <- list()

    for (i in 1:nrow(focal_combinations)) {
      T_set <- focal_combinations$T_val[i]
      R_set <- focal_combinations$R_val[i]

      new_df <- data_country |>
        mutate(
          der_partisan_type = T_set,
          der_partisan_relationship = factor(R_set, levels = R_levels)
        )

      condition_id <- paste0("T", T_set, "_R", R_set)
      country_list[[condition_id]] <- new_df
    }

    newdata_country_list[[as.character(country)]] <- country_list
  }

  return(newdata_country_list)
}

```

### Step 2: Draw from posterior EV

```{r}
#| label: estimate-evs-function

# 2. Function to estimate Expected Values (EVs) using epred()
# -----------------------------------------------------------

#' Estimates Expected Values (EVs) for each T × R scenario using posterior_epred().
#'
#' @param bfit_model The fitted brms model object.
#' @param newdata_list Either:
#'        - pooled mode: list of 6 data frames
#'        - country mode: nested list like list[["Country"]][["Scenario"]] = df
#' @param mode Either "pooled" or "country".
#' @param re_formula_setting Passed to posterior_epred()
#'
#' @return A list containing:
#'   - epreds_list: list (pooled) or nested list (countries → scenarios)
#'   - N_obs: number of observations (single value for pooled; vector for country mode)
#' @export
estimate_evs <- function(
  bfit_model,
  newdata_list,
  mode = c("pooled", "country"),
  re_formula_setting = NULL
) {
  # Ensure mode is correctly chosen
  mode <- match.arg(mode)

  message("Running estimate_evs() in mode: ", toupper(mode))

  # ---------------------------------------------------------
  # Helper: Safe posterior_epred wrapper
  # ---------------------------------------------------------
  run_one_epred <- function(df, cond_name, country = NULL) {
    tryCatch(
      posterior_epred(
        bfit_model,
        newdata = df,
        re_formula = re_formula_setting
      ),
      error = function(e) {
        prefix <- if (is.null(country)) {
          paste("epred failed in pooled scenario", cond_name)
        } else {
          paste("epred failed for", country, "scenario", cond_name)
        }
        warning(prefix, " — ", e$message)
        return(NULL)
      }
    )
  }

  # ---------------------------------------------------------
  # MODE 1 → COUNTRY-SPECIFIC (nested list)
  # ---------------------------------------------------------
  if (mode == "country") {
    country_names <- names(newdata_list)
    result_nested <- list()
    N_per_country <- c()

    for (ct in country_names) {
      scenarios <- names(newdata_list[[ct]])
      result_nested[[ct]] <- list()

      # number of rows per scenario (should all be identical)
      N_per_country[ct] <- nrow(newdata_list[[ct]][[1]])

      for (sc in scenarios) {
        df <- newdata_list[[ct]][[sc]]
        result_nested[[ct]][[sc]] <- run_one_epred(df, sc, ct)
      }
    }

    return(list(
      epreds_list = result_nested,
      N_obs = N_per_country
    ))
  }

  # ---------------------------------------------------------
  # MODE 2 → POOLED (flat list of 6 dfs)
  # ---------------------------------------------------------
  if (mode == "pooled") {
    scenario_names <- names(newdata_list)

    epreds_list <- map(scenario_names, function(sc) {
      df <- newdata_list[[sc]]
      run_one_epred(df, sc, country = NULL)
    }) |>
      set_names(scenario_names)

    return(list(
      epreds_list = epreds_list,
      N_obs = nrow(bfit_model$data)
    ))
  }
}
```

### Step 3: turn EV into QoIs

```{r}
#| label: tidy-qoi-function

# 3. Function to estimate QoIs (AP, IF, OD, CATEs) and tidy the output
# --------------------------------------------------------------------

#' Calculates and tidies the posterior distributions for all Quantities of Interest (QoIs).
#'
#' This function takes the epred list output, applies the row filter (for country/overall),
#' calculates the APE (rowMeans), then calculates AP/IF/OD and CATEs,
#' and returns the result in a long format suitable for tidybayes.
#'
#' @param epred_result The list output from estimate_evs() containing epreds_list.
#' @param filter_rows A vector of row indices from the *original* data (1 to N)
#'        to include in the APE calculation (e.g., all N for overall, or a subset
#'        for a specific country).
#' @param analysis_id A character string identifying the analysis (e.g., "Pooled", "Austria").
#' @return A long-format tibble ready for tidybayes/ggplot2.
calculate_qois_tidy <- function(
  epred_result,
  filter_rows = 1:epred_result$N_obs,
  analysis_id = "Pooled"
) {
  # Check for failed epred result
  if (is.null(epred_result) || is.null(epred_result$epreds_list)) {
    warning(
      "Cannot calculate QoIs: epred_result is NULL or missing epreds_list."
    )
    return(tibble())
  }

  epreds_list <- epred_result$epreds_list

  # --- Step A: Calculate the 6 APEs (rowMeans) for the specified filter_rows ---
  # Iterate over the 6 posterior matrices
  ape_posteriors <- purrr::map(names(epreds_list), function(cond_name) {
    epred_matrix <- epreds_list[[cond_name]]

    # 1. Subset the matrix rows based on the filter_rows (for country/overall)
    # epred_matrix is [Draws x N], so we subset the columns here
    epred_subset <- epred_matrix[, filter_rows]

    # 2. Calculate the APE for this specific condition and filtered group
    return(rowMeans(epred_subset))
  }) |>
    # Name the resulting list of vectors (the 6 APE distributions)
    set_names(names(epreds_list)) |>
    as_tibble()

  # --- Step B: Calculate the difference QoIs (AP, IF, OD, CATEs) ---

  AP_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_ROut
  AP_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_ROut
  IF_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_RNone
  IF_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_RNone
  OD_T1 <- ape_posteriors$T1_RNone - ape_posteriors$T1_ROut
  OD_T0 <- ape_posteriors$T0_RNone - ape_posteriors$T0_ROut
  CATE_AP <- AP_T1 - AP_T0
  CATE_IF <- IF_T1 - IF_T0
  CATE_OD <- OD_T1 - OD_T0

  # --- Step C: Combine and Transform to Tidy (Long) Format ---

  all_qois_wide <- ape_posteriors |>
    add_column(
      AP_Expl = AP_T1,
      AP_Impl = AP_T0,
      IF_Expl = IF_T1,
      IF_Impl = IF_T0,
      OD_Expl = OD_T1,
      OD_Impl = OD_T0,
      CATE_AP = CATE_AP,
      CATE_IF = CATE_IF,
      CATE_OD = CATE_OD
    ) |>
    mutate(.draw = 1:n()) |> # Mandatory column for tidybayes
    mutate(Analysis = analysis_id)

  qois_tidy <- all_qois_wide |>
    pivot_longer(
      cols = -c(.draw, Analysis),
      names_to = "Quantity",
      values_to = "Estimate"
    )

  return(qois_tidy)
}

```

### Step 4: Plot results

```{r}
#| label: plot-function

# 4. Function to ggplot main effects (Halfeye of conditional means and CATE)
# -------------------------------------------------------------------------

#' Generates the ggplot object for the pooled (main) effects.
#'
#' This function generates two plots: one for the 6 Expected Values (EVs)
#' and one combined, faceted plot for the 9 Difference Metrics (AP/IF/OD x Expl/Impl/CATE).
#'
#' @param tidybayes_df The output from calculate_qois_tidy() filtered for the "Pooled" analysis.
#' @return A list of two ggplot objects: Conditional_Means_Plot and QoI_CATE_Plot.
plot_pooled_results <- function(tidybayes_df) {
  # 1. Prepare data for the two panels & EV

  # ---  Conditional Means (EVs) ---
  ev_data <- tidybayes_df |>
    filter(
      Quantity %in%
        c("T1_RCo", "T0_RCo", "T1_ROut", "T0_ROut", "T1_RNone", "T0_RNone")
    ) |>
    separate_wider_delim(
      Quantity,
      delim = "_",
      names = c("Partisan_Type", "Relationship_Code")
    ) |>
    mutate(
      Partisan_Type = factor(
        Partisan_Type,
        levels = c("T1", "T0"),
        labels = c("Explicit Partisan (T=1)", "Implicit Partisan (T=0)")
      ),
      Relationship_Type = factor(
        Relationship_Code,
        levels = c("RCo", "ROut", "RNone"),
        labels = c("Co-Partisan", "Out-Partisan", "Neutral")
      )
    ) |>
    select(-Relationship_Code)

  # --- Main Figure: Polarization/Favoritism/Derogation (AP, IF, OD, CATEs) ---
  qoi_data <- tidybayes_df |>
    filter(
      Quantity %in%
        c(
          "AP_Expl",
          "AP_Impl",
          "IF_Expl",
          "IF_Impl",
          "OD_Expl",
          "OD_Impl",
          "CATE_AP",
          "CATE_IF",
          "CATE_OD"
        )
    ) |>
    mutate(
      Metric_Code = case_when(
        grepl("CATE", Quantity) ~ gsub("CATE_", "", Quantity), # e.g., AP, IF, OD
        grepl("AP", Quantity) ~ "AP",
        grepl("IF", Quantity) ~ "IF",
        grepl("OD", Quantity) ~ "OD"
      ),
      Type = case_when(
        grepl("CATE", Quantity) ~ "Conditional Average Treatment Effect",
        grepl("Expl", Quantity) ~ "Explicit\n(T=1)",
        grepl("Impl", Quantity) ~ "Implicit\n(T=0)",
        TRUE ~ NA_character_
      )
    ) |>
    # Convert Metric to clean factor for plotting order
    mutate(
      Metric_Name = factor(
        Metric_Code,
        levels = c("AP", "IF", "OD"),
        labels = c(
          "Affective Polarization (AP)",
          "Ingroup Favoritism (IF)",
          "Outgroup Derogation (OD)"
        )
      ),
      # Set plotting order for the y-axis within each facet
      Plot_Order = factor(
        Type,
        levels = c(
          "Conditional Average Treatment Effect",
          "Implicit\n(T=0)",
          "Explicit\n(T=1)"
        )
      )
    )

  # --- PLOT GENERATION ---

  # Conditional Means (EVs)
  p_ev <- ggplot(
    ev_data,
    aes(
      x = Estimate,
      y = Relationship_Type,
      fill = Partisan_Type
    )
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    facet_wrap(~Partisan_Type, ncol = 1) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "grey"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Tokens Allocated (0-10)",
      y = "Relationship Type"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  # Right panel: Combined QoI and CATE effects
  max_range <- max(abs(qoi_data$Estimate)) * 1.1

  # FIG: AP --------------------------------------------------------------------
  p_ap_left <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "AP",
        Type != "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order, fill = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "#CCCCCC"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Affective Polarization (AP)",
      y = "Partisan Type (T)"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  p_ap_right <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "AP",
        Type == "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1
    ) +
    labs(
      x = expression(CATE[AP]),
      y = " "
    ) +
    scale_x_continuous(
      limits = c(-0.5, 0.5)
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1.618034,
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.x = element_text(
        angle = 45,
        hjust = 1
      )
    )

  p_ap <- p_ap_left + p_ap_right

  # FIG: IF --------------------------------------------------------------------
  p_if_left <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "IF",
        Type != "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order, fill = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "#CCCCCC"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Ingroup Favoritism (IF)",
      y = "Partisan Type (T)"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  p_if_right <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "IF",
        Type == "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1
    ) +
    labs(
      x = expression(CATE[IF]),
      y = " "
    ) +
    scale_x_continuous(
      limits = c(-0.5, 0.5)
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1.618034,
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.x = element_text(
        angle = 45,
        hjust = 1
      )
    )

  p_if <- p_if_left + p_if_right

  # FIG: OD --------------------------------------------------------------------
  p_od_left <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "OD",
        Type != "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order, fill = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    scale_fill_manual(
      values = c(
        "Explicit\n(T=1)" = "white",
        "Implicit\n(T=0)" = "#CCCCCC"
      ),
      name = "Partisan Type"
    ) +
    labs(
      x = "Outgroup Derogation (OD)",
      y = "Partisan Type (T)"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1 / 1.618034
    )

  p_od_right <- ggplot(
    qoi_data |>
      filter(
        Metric_Code == "OD",
        Type == "Conditional Average Treatment Effect"
      ),
    aes(x = Estimate, y = Plot_Order)
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.5,
      slab_color = "black",
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1
    ) +
    labs(
      x = expression(CATE[OD]),
      y = " "
    ) +
    scale_x_continuous(
      limits = c(-0.5, 0.5)
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      strip.background = element_rect(fill = "grey90", color = "grey50"),
      aspect.ratio = 1.618034,
      axis.text.y = element_blank(),
      axis.ticks.y = element_blank(),
      axis.text.x = element_text(
        angle = 45,
        hjust = 1
      )
    )

  p_od <- p_od_left + p_od_right

  # Return the two main plots
  return(list(
    Conditional_Means_Plot = p_ev,
    AP_Plot = p_ap,
    IF_Plot = p_if,
    OD_Plot = p_od
  ))
}
```


### Step 5: Country analyses

```{r}
#| label: country-analysis-fun

# 5. Function to run country-specific QoI analysis with full QoIs
# ----------------------------------------------------------------

#' Calculates AP, IF, OD, and CATE QoIs for each country using nested epred output.
#'
#' Expects epred_result from estimate_evs() in country-mode:
#'   epred_result$epreds_list[["Austria"]][["T1_RCo"]] = epred matrix
#'
#' @param bfit_model The fitted brms model object (metadata only).
#' @param epred_result Output from estimate_evs() with nested epreds_list.
#'
#' @return A tidy tibble of QoI estimates for all countries combined.
run_country_analysis <- function(bfit_model, epred_result) {
  epreds_nested <- epred_result$epreds_list

  if (!is.list(epreds_nested) || !is.list(epreds_nested[[1]])) {
    stop("epred_result does not contain nested country-specific epreds_list.")
  }

  country_names <- names(epreds_nested)
  message(
    "Starting country-specific analysis for ",
    length(country_names),
    " countries."
  )

  # Function to compute full QoIs from epred matrices for one country
  compute_qois <- function(epreds_scen_list, country_name) {
    # --- Step A: calculate APEs (rowMeans) for each scenario ---
    ape_posteriors <- purrr::map(names(epreds_scen_list), function(scen) {
      mat <- epreds_scen_list[[scen]]
      if (!is.matrix(mat)) {
        stop("Scenario epred is not a matrix")
      }
      rowMeans(mat) # mean across columns (observations) per draw
    }) |>
      set_names(names(epreds_scen_list)) |>
      as_tibble()

    # --- Step B: Calculate AP, IF, OD, and CATEs ---
    AP_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_ROut
    AP_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_ROut
    IF_T1 <- ape_posteriors$T1_RCo - ape_posteriors$T1_RNone
    IF_T0 <- ape_posteriors$T0_RCo - ape_posteriors$T0_RNone
    OD_T1 <- ape_posteriors$T1_RNone - ape_posteriors$T1_ROut
    OD_T0 <- ape_posteriors$T0_RNone - ape_posteriors$T0_ROut
    CATE_AP <- AP_T1 - AP_T0
    CATE_IF <- IF_T1 - IF_T0
    CATE_OD <- OD_T1 - OD_T0

    # --- Step C: Combine to tidy long format ---
    all_qois_wide <- ape_posteriors |>
      add_column(
        AP_Expl = AP_T1,
        AP_Impl = AP_T0,
        IF_Expl = IF_T1,
        IF_Impl = IF_T0,
        OD_Expl = OD_T1,
        OD_Impl = OD_T0,
        CATE_AP = CATE_AP,
        CATE_IF = CATE_IF,
        CATE_OD = CATE_OD
      ) |>
      mutate(.draw = 1:n(), Analysis = country_name)

    qois_tidy <- all_qois_wide |>
      pivot_longer(
        cols = -c(.draw, Analysis),
        names_to = "Quantity",
        values_to = "Estimate"
      )

    return(qois_tidy)
  }

  # --- Loop over countries ---
  all_country_qois <- purrr::map(country_names, function(ct) {
    ct_epreds <- epreds_nested[[ct]]
    if (!all(map_lgl(ct_epreds, is.matrix))) {
      warning("Invalid epred structure for country: ", ct)
      return(NULL)
    }
    compute_qois(ct_epreds, ct)
  }) |>
    bind_rows()

  if (nrow(all_country_qois) == 0) {
    stop("Country analysis resulted in an empty output tibble.")
  }

  return(all_country_qois)
}
```

### Step 6: Country result plots

```{r}
#| label: country-plots-fun

plot_country_results <- function(country_qois_df) {
  # ===============================
  # 1. Prepare CATE data (unchanged)
  # ===============================
  cate_data <- country_qois_df |>
    filter(Quantity %in% c("CATE_AP", "CATE_IF", "CATE_OD")) |>
    mutate(
      Metric_Code = case_when(
        Quantity == "CATE_AP" ~ "AP",
        Quantity == "CATE_IF" ~ "IF",
        Quantity == "CATE_OD" ~ "OD"
      ),
      Country = factor(Analysis)
    )

  # -------------------------------
  # Combined CATE Plot Across Countries (current behavior)
  # -------------------------------
  p_country_cate <- ggplot(
    cate_data,
    aes(
      x = Estimate,
      y = forcats::fct_reorder(Country, Estimate, .fun = median)
    )
  ) +
    stat_halfeye(
      .width = c(0.95, 0.99),
      point_interval = "median_qi",
      slab_size = 0.3,
      slab_fill = "#666666",
      point_fill = "white",
      point_color = "black",
      shape = 21,
      stroke = 1.5
    ) +
    geom_vline(
      xintercept = 0,
      linetype = "dashed",
      linewidth = 1
    ) +
    labs(
      x = "CATE",
      y = "Country"
    ) +
    theme_pubr() +
    theme(
      legend.position = "none",
      axis.text.x = element_text(
        angle = 45,
        hjust = 1
      )
    ) +
    facet_wrap(
      ~Metric_Code,
      ncol = 3,
      labeller = label_bquote(CATE[.(Metric_Code)])
    )

  # =======================================================
  # 2. Generate EV plots for each country (NEW)
  #    Mirrors pooled AP/IF/OD EV logic
  # =======================================================

  ev_data <- country_qois_df |>
    filter(
      Quantity %in%
        c("T1_RCo", "T0_RCo", "T1_ROut", "T0_ROut", "T1_RNone", "T0_RNone")
    ) |>
    separate_wider_delim(
      Quantity,
      delim = "_",
      names = c("Partisan_Type", "Relationship_Code")
    ) |>
    mutate(
      Partisan_Type = factor(
        Partisan_Type,
        levels = c("T1", "T0"),
        labels = c("Explicit Partisan (T=1)", "Implicit Partisan (T=0)")
      ),
      Relationship_Type = factor(
        Relationship_Code,
        levels = c("RCo", "ROut", "RNone"),
        labels = c("Co-Partisan", "Out-Partisan", "Neutral")
      ),
      Country = Analysis
    ) |>
    select(-Relationship_Code)

  # ------------------------------------
  # Function to produce one-country EV plot
  # ------------------------------------
  make_country_ev_plot <- function(df_country) {
    ggplot(
      df_country,
      aes(x = Estimate, y = Relationship_Type, fill = Partisan_Type)
    ) +
      stat_halfeye(
        .width = c(0.95, 0.99),
        point_interval = "median_qi",
        slab_size = 0.5,
        slab_color = "black",
        point_fill = "white",
        point_color = "black",
        shape = 21,
        stroke = 1.5
      ) +
      facet_wrap(~Partisan_Type, ncol = 1) +
      scale_fill_manual(
        values = c(
          "Explicit Partisan (T=1)" = "white",
          "Implicit Partisan (T=0)" = "grey"
        )
      ) +
      labs(
        x = "Tokens Allocated (0–10)",
        y = "Relationship Type",
        title = unique(df_country$Country)
      ) +
      theme_pubr() +
      scale_x_continuous(limits = c(2.5, 5)) +
      theme(
        legend.position = "none",
        strip.background = element_rect(fill = "grey90", color = "grey50"),
        aspect.ratio = 1 / 1.618034
      )
  }

  # ----------------------
  # Build list of per-country plots
  # ----------------------
  country_list <- split(ev_data, ev_data$Country)

  ev_plots <- lapply(country_list, make_country_ev_plot)
  names(ev_plots) <- names(country_list)

  # ============================================
  # 3. Return list containing:
  #    - combined CATE plot
  #    - per-country EV plots
  # ============================================
  return(list(
    Country_CATE_Plot = p_country_cate,
    Country_EVs = ev_plots
  ))
}

```

# Run pipelines

## Pooled analyses

### Base model d

```{r, message = NA}
#| label: analysis-base-d

newdata_base_d <- create_ape_newdata(bfit_base_d)

evs_base_d <- estimate_evs(bfit_base_d, newdata_base_d, re_formula_setting = NA)

qois_base_d <- calculate_qois_tidy(evs_base_d)

plot_base_d <- plot_pooled_results(qois_base_d)

save(
  plot_base_d,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_base_d.RData"
  )
)

save(
  qois_base_d,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_base_d.RData"
  )
)

rm(evs_base_d, qois_base_d, plot_base_d)
```

### Base model t

```{r, message = NA}
#| label: analysis-base-t

newdata_base_t <- create_ape_newdata(bfit_base_t)

evs_base_t <- estimate_evs(bfit_base_t, newdata_base_t, re_formula_setting = NA)

qois_base_t <- calculate_qois_tidy(evs_base_t)

plot_base_t <- plot_pooled_results(qois_base_t)

save(
  plot_base_t,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_base_t.RData"
  )
)

save(
  plot_base_t,
  file = here(
    "data",
    "03_final",
    "qois",
    "plot_base_t.RData"
  )
)

rm(evs_base_t, qois_base_t, plot_base_t)
```

### Cov model d

```{r, message = NA}
#| label: analysis-cov-d

newdata_cov_d <- create_ape_newdata(bfit_cov_d)

evs_cov_d <- estimate_evs(bfit_cov_d, newdata_cov_d, re_formula_setting = NA)

qois_cov_d <- calculate_qois_tidy(evs_cov_d)

plot_cov_d <- plot_pooled_results(qois_cov_d)

save(
  plot_cov_d,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_cov_d.RData"
  )
)

save(
  qois_cov_d,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_cov_d.RData"
  )
)

rm(evs_cov_d, qois_cov_d, plot_cov_d)
```

### Cov model t

```{r, message = NA}
#| label: analysis-cov-t

newdata_cov_t <- create_ape_newdata(bfit_cov_t)

evs_cov_t <- estimate_evs(bfit_cov_t, newdata_cov_t, re_formula_setting = NA)

qois_cov_t <- calculate_qois_tidy(evs_cov_t)

plot_cov_t <- plot_pooled_results(qois_cov_t)

save(
  plot_cov_t,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_cov_t.RData"
  )
)

save(
  qois_cov_t,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_cov_t.RData"
  )
)

rm(evs_cov_t, qois_cov_t, plot_cov_t)
```

## Country analyses

### Base d

```{r, message = T}
#| label: analysis-country-base-d

newdata_country_base_d <- create_ape_newdata(
  bfit_model = bfit_base_d,
  by_country = TRUE,
  country_var = "meta_country"
)

evs_country_base_d <- estimate_evs(
  bfit_base_d,
  newdata_country_base_d,
  mode = "country",
  re_formula_setting = NULL
)

qois_country_base_d <- run_country_analysis(
  bfit_base_d,
  evs_country_base_d
)

plot_country_base_d <- plot_country_results(
  qois_country_base_d
)

save(
  plot_country_base_d,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_country_base_d.RData"
  )
)

save(
  qois_country_base_d,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_country_base_d"
  )
)

rm(evs_country_base_d, qois_country_base_d, plot_country_base_d)
```

### Base t

```{r, message = T}
#| label: analysis-country-base-t

newdata_country_base_t <- create_ape_newdata(
  bfit_model = bfit_base_t,
  by_country = TRUE,
  country_var = "meta_country"
)

evs_country_base_t <- estimate_evs(
  bfit_base_t,
  newdata_country_base_t,
  mode = "country",
  re_formula_setting = NULL
)

qois_country_base_t <- run_country_analysis(
  bfit_base_t,
  evs_country_base_t
)

plot_country_base_t <- plot_country_results(
  qois_country_base_t
)

save(
  plot_country_base_t,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_country_base_t.RData"
  )
)

save(
  qois_country_base_t,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_country_base_t"
  )
)

rm(evs_country_base_t, qois_country_base_t, plot_country_base_t)
```

### Cov d

```{r, message = T}
#| label: analysis-country-cov-d

newdata_country_cov_d <- create_ape_newdata(
  bfit_model = bfit_cov_d,
  by_country = TRUE,
  country_var = "meta_country"
)

evs_country_cov_d <- estimate_evs(
  bfit_cov_d,
  newdata_country_cov_d,
  mode = "country",
  re_formula_setting = NULL
)

qois_country_cov_d <- run_country_analysis(
  bfit_cov_d,
  evs_country_cov_d
)

plot_country_cov_d <- plot_country_results(
  qois_country_cov_d
)

save(
  plot_country_cov_d,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_country_cov_d.RData"
  )
)

save(
  qois_country_cov_d,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_country_cov_d"
  )
)

rm(evs_country_cov_d, qois_country_cov_d, plot_country_cov_d)
```

### Cov t

```{r, message = T}
#| label: analysis-country-cov-t

newdata_country_cov_t <- create_ape_newdata(
  bfit_model = bfit_cov_t,
  by_country = TRUE,
  country_var = "meta_country"
)

evs_country_cov_t <- estimate_evs(
  bfit_cov_t,
  newdata_country_cov_t,
  mode = "country",
  re_formula_setting = NULL
)

qois_country_cov_t <- run_country_analysis(
  bfit_cov_t,
  evs_country_cov_t
)

plot_country_cov_t <- plot_country_results(
  qois_country_cov_t
)


save(
  plot_country_cov_t,
  file = here(
    "data",
    "03_final",
    "plots",
    "plot_country_cov_t.RData"
  )
)

save(
  qois_country_cov_t,
  file = here(
    "data",
    "03_final",
    "qois",
    "qois_country_cov_t"
  )
)

rm(evs_country_cov_t, qois_country_cov_t, plot_country_cov_t)
```

# Session Info

```{r}
#| label: session-info

session_info()
```


# Render Time

```{r}
#| label: render-time

end_time <- Sys.time()

rendering_time <- end_time - start_time

message(paste(
  "Document rendered in:",
  round(as.numeric(rendering_time, units = "secs"), 2),
  "seconds.
"
))
```